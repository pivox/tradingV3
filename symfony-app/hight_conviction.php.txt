<?php
declare(strict_types=1);

namespace App\Trading\Strategy;

use App\Trading\Indicators\AtrCalculator;
use App\Trading\Risk\PositionSizer;

/**
 * Enums simples pour les contextes directionnels
 */
final class Bias
{
    public const LONG   = 'LONG';
    public const SHORT  = 'SHORT';
    public const NEUTRE = 'NEUTRE';

    public static function all(): array { return [self::LONG, self::SHORT, self::NEUTRE]; }
}

/**
 * Contrats d'accès aux données (à implémenter côté infra)
 */
interface IndicatorsProviderInterface
{
    public function adx(string $symbol, string $timeframe, int $length = 14): float;
    public function macd(string $symbol, string $timeframe): array; // ['macd'=>..., 'signal'=>..., 'hist'=>...]
    public function rsi(string $symbol, string $timeframe, int $length = 14): float;
    public function vwap(string $symbol, string $timeframe): float;
    public function obvDelta(string $symbol, string $timeframe, int $lookback = 5): float;
    public function volume(string $symbol, string $timeframe, int $lookback = 20): array; // ['now'=>..., 'sma'=>...]
    public function bollingerWidthPct(string $symbol, string $timeframe, int $length = 20, float $dev = 2.0): float;
    public function choppiness(string $symbol, string $timeframe, int $length = 14): float;
    public function atr(string $symbol, string $timeframe, int $length = 14): float;
    public function donchianBreakout(string $symbol, string $timeframe, int $n = 20): ?string; // 'UP','DOWN',null
}

interface CalendarFeedInterface
{
    /** Retourne true s'il y a un évènement macro critique dans la fenêtre [now-60, now+30] min */
    public function hasImminentRiskEvent(array $watchList = ['FOMC','CPI','NFP','RateDecision'], int $blackoutBeforeMin = 60, int $blackoutAfterMin = 30): bool;
}

interface ExchangeInfoInterface
{
    /** Prix de liquidation estimé pour une position isolée */
    public function estimateLiquidationPrice(string $symbol, string $side, float $entry, float $qty, float $leverage, float $marginUsd): float;

    /** Tick/step pour la quantization (facultatif mais conseillé) */
    public function quantization(string $symbol): array; // ['tick'=>..., 'step'=>...]
}

/**
 * Entrée de validation
 */
final class HighConvictionInput
{
    public function __construct(
        public string $symbol,
        public string $bias4h,   // Bias::LONG|SHORT|NEUTRE
        public string $bias1h,
        public string $exec15m,  // signal d’exécution (LONG/SHORT)
        public float  $entryPrice,
        public float  $stopPrice,
        public float  $tpTechPrice,
        public float  $availableUsdt,   // règle budget min(100, solde)
        public int    $leverageCap = 50
    ) {}
}

/**
 * Résultat de validation + sizing
 */
final class HighConvictionResult
{
    public function __construct(
        public bool   $isEligible,
        public array  $fails,            // liste des raisons d’échec
        public ?float $riskPct,          // % risk/trade (capé 2 %)
        public ?float $targetLeverage,   // levier conseillé (capé 50x)
        public ?float $positionQty,      // taille en coin
        public ?float $liqPrice          // prix de liquidation estimé
    ) {}
}

/**
 * Implémentation de la stratégie "high_conviction"
 */
final class HighConvictionStrategy
{
    public function __construct(
        private IndicatorsProviderInterface $ind,
        private CalendarFeedInterface       $calendar,
        private ExchangeInfoInterface       $exchange,
        private AtrCalculator               $atrCalc,
        private PositionSizer               $sizer
    ) {}

    public function validateAndSize(HighConvictionInput $in): HighConvictionResult
    {
        $fails = [];

        // 0) Règles de base & paramètres
        $baseRiskPct   = 2.0;
        $maxRiskPct    = 2.0;           // pas d'over-risk
        $budgetUsdt    = min(100.0, $in->availableUsdt);
        $stopMinPct    = 0.25;          // % (ex: 0.25 %)
        $rrThreshold   = 5.0;
        $liqGuardMul   = 3.0;
        $k             = 10.0;          // levier dynamique
        $levPlancher   = 3.0;
        $levPlafond    = $in->leverageCap;

        $side = ($in->exec15m === Bias::LONG) ? 'LONG' : 'SHORT';

        // 1) Confluence MTF (all_equal_non_neutral)
        if (!in_array($in->bias4h, [Bias::LONG, Bias::SHORT], true)
            || !in_array($in->bias1h, [Bias::LONG, Bias::SHORT], true)
            || !in_array($in->exec15m, [Bias::LONG, Bias::SHORT], true)
            || !($in->bias4h === $in->bias1h && $in->bias1h === $in->exec15m)) {
            $fails[] = 'multi_timeframe_alignment';
        }

        // 2) Trend strength: ADX > 25 sur 1h & 15m (buffer 1.0)
        $adx1h  = $this->ind->adx($in->symbol, '1h', 14);
        $adx15m = $this->ind->adx($in->symbol, '15m', 14);
        if (min($adx1h, $adx15m) < 26.0) {
            $fails[] = 'trend_strength_adx';
        }

        // 3) Breakout confirmé par le volume + VWAP + OBV
        $break = $this->ind->donchianBreakout($in->symbol, '15m', 20); // 'UP','DOWN',null
        $okBreakSide = ($side === 'LONG' && $break === 'UP') || ($side === 'SHORT' && $break === 'DOWN');
        $vol = $this->ind->volume($in->symbol, '15m', 20); // ['now','sma']
        $volOk = ($vol['sma'] > 0) && ($vol['now'] >= 1.5 * $vol['sma']);
        $obvOk = $this->ind->obvDelta($in->symbol, '15m', 5) * ($side === 'LONG' ? 1 : -1) > 0;
        $priceVsVwapOk = ($side === 'LONG' && $in->entryPrice >= $this->ind->vwap($in->symbol, '15m'))
                      || ($side === 'SHORT' && $in->entryPrice <= $this->ind->vwap($in->symbol, '15m'));
        if (!($okBreakSide && $volOk && ($obvOk || $priceVsVwapOk))) {
            $fails[] = 'breakout_with_volume';
        }

        // 4) Expansion de volatilité après contraction (Bollinger squeeze + ATR up)
        $bbWidthPct = $this->ind->bollingerWidthPct($in->symbol, '15m', 20, 2.0); // (BB_width / SMA) * 100
        $chop       = $this->ind->choppiness($in->symbol, '15m', 14);
        $atrNow     = $this->ind->atr($in->symbol, '15m', 14);
        $atrPrev    = $this->ind->atr($in->symbol, '15m', 14); // à remplacer par valeur(t-1) dans ton provider
        $expansion  = ($chop <= 38.0 || $bbWidthPct <= $this->percentile5LookbackPlaceholder())
                   && ($atrNow > $atrPrev); // ou 3 barres up si dispo
        if (!$expansion) {
            $fails[] = 'volatility_expansion';
        }

        // 5) Pas d’évènement macro imminent
        if ($this->calendar->hasImminentRiskEvent()) {
            $fails[] = 'no_macro_event';
        }

        // 6) RR guard (≥5:1) & stop minimal
        $stopPct = abs(($in->entryPrice - $in->stopPrice) / $in->entryPrice) * 100.0;
        if ($stopPct < $stopMinPct) {
            $fails[] = 'stop_min_pct';
        }
        $reward = abs($in->tpTechPrice - $in->entryPrice);
        $risk   = abs($in->entryPrice - $in->stopPrice);
        $rr     = $risk > 0 ? $reward / $risk : 0.0;
        if ($rr < $rrThreshold) {
            $fails[] = 'rr_guard';
        }

        // 7) Sizing: risk % (cap 2 %) + levier dynamique (k/stop%)
        $riskPct = min($baseRiskPct, $maxRiskPct);
        $targetLev = max($levPlancher, min($levPlafond, ($stopPct > 0 ? $k / $stopPct : $levPlafond)));

        // Budget ouverture (min(100, solde dispo))
        $budget = $budgetUsdt;

        // Taille & qty via PositionSizer (stop ATR/structure) – tu as déjà ce service
        $size = $this->sizer->sizeFromRisk(
            symbol: $in->symbol,
            side: strtolower($side),        // 'long'|'short'
            entryPrice: $in->entryPrice,
            stopPrice: $in->stopPrice,
            riskPct: $riskPct,
            budgetUsd: $budget,
            leverage: $targetLev
        );
        // $size doit retourner ['qty'=>..., 'marginUsd'=>..., 'notionalUsd'=>...]

        // 8) Liquidation guard (≥ 3× stop)
        $liq = $this->exchange->estimateLiquidationPrice(
            $in->symbol, $side, $in->entryPrice, $size['qty'], $targetLev, $size['marginUsd']
        );
        $stopDist = abs($in->entryPrice - $in->stopPrice);
        $liqDist  = abs($liq - $in->entryPrice);
        if (!($liqDist >= $liqGuardMul * $stopDist)) {
            $fails[] = 'liquidation_guard';
        }

        $eligible = empty($fails);

        return new HighConvictionResult(
            isEligible:     $eligible,
            fails:          $fails,
            riskPct:        $eligible ? $riskPct : null,
            targetLeverage: $eligible ? $targetLev : null,
            positionQty:    $eligible ? $size['qty'] : null,
            liqPrice:       $eligible ? $liq : null
        );
    }

    /**
     * Placeholder: remplace par un vrai calcul percentile(5) de la largeur des bandes
     * sur une fenêtre (ex. 252 *barres*). Ici, on renvoie 5 % pour montrer l’idée.
     */
    private function percentile5LookbackPlaceholder(): float
    {
        return 5.0; // % de largeur/price
    }
}
