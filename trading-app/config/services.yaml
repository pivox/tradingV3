# This file is the entry point to configure your own services and load the default configuration.
# If you want to remove a service, deprecate it, or change its class, you can apply the changes here.
#
# If you are *not* using the default services.yaml file in your package, you *must* pass an
# absolute path to this file's location to the `imports` key in your package's services.yaml (e.g.
# imports: ['%kernel.project_dir%/config/services.yaml'])
#
# See https://symfony.com/doc/current/configuration.html#importing-the-routing-configuration

imports:

parameters:
    app.mtf_log_level: 'info'
    # Configuration pour le backtesting avec une heure fixe
    app.clock.fixed_time: null  # null = temps réel, sinon DateTimeImmutable pour backtesting
    bitmart_public_base_uri: '%env(string:BITMART_PUBLIC_API_URL)%'
    bitmart_private_base_uri: '%env(string:BITMART_PRIVATE_API_URL)%'
    trade_entry.order_timeout_seconds: 120
    # Durée de réactivation du MtfSwitch après annulation d'ordre (au lieu de 4h)
    env(ORDER_TIMEOUT_SWITCH_DURATION): '15m'
    mode:
        - [name: 'regular', enabled: false, priority: 0]
        - [name: 'scalper', enabled: false, priority: 1]
        - [name: 'scalper_micro', enabled: true, priority: 2]

    # Fallbacks when env vars are missing (useful in CLI/worker containers)
    router.default_uri: 'http://trading-app-nginx'
    messenger.transport.dsn: 'doctrine://default?queue_name=log_messages'
    # Default values for env-backed log levels (so env is optional)
    env(MTF_LOG_LEVEL): 'info'
    env(LOG_LEVEL_MAIN): 'info'
    env(LOG_LEVEL_SIGNALS): 'info'
    env(LOG_LEVEL_POSITIONS): 'info'
    env(LOG_LEVEL_PROVIDER): 'info'
    env(LOG_LEVEL_INDICATORS): 'info'
    env(LOG_LEVEL_HIGHCONVICTION): 'info'
    env(LOG_LEVEL_PIPELINE_EXEC): 'info'
    app.trade_entry_default_mode: 'scalper_micro'

    # Configuration TradeEntry - Valeurs par défaut (déplacées dans services_trade_entry.yaml)

    # Configuration MTF/Decision: déplacée dans config/app/mtf_validations.yaml (mtf_validation.defaults)
services:
    # default configuration for services in *this* file
    _defaults:
        autowire: true      # Automatically injects dependencies in your services.
        autoconfigure: true # Automatically registers your services as commands, event subscribers, etc.

    # makes classes in src/ available to be used as services
    # this creates a service per class whose id is the fully-qualified class name
    App\:
        resource: '../src/'
        exclude:
            - '../src/DependencyInjection/'
            - '../src/Entity/'
            - '../src/Kernel.php'
            - '../src/*/LookAtit'
            - '../src/Provider/'

    # Loggers dedicated to the provider module
    App\Provider\:
        resource: '../src/Provider/'
        exclude:
            - '../src/Provider/Entity/'
            - '../src/Provider/Bitmart/'
        bind:
            $logger: '@monolog.logger.provider'

    App\Provider\Bitmart\:
        resource: '../src/Provider/Bitmart/'
        bind:
            $logger: '@monolog.logger.bitmart'

    # add more service definitions when explicit configuration is needed
    # please note that last definitions always *replace* previous ones



    # MTF Services
    # Services de timeframe MTF - Configuration supprimée pour utiliser l'auto-wiring

    # Configuration Redis temporaire pour résoudre le problème LockManager
    # Option 1: Redis réel (décommentez si Redis est disponible)
    # Redis:
    #     class: Redis
    #     calls:
    #         - [connect, ['127.0.0.1', 6379]]

    # Option 2: Mock Redis pour les tests (décommentez si Redis n'est pas disponible)
    Redis:
        class: App\Runtime\Concurrency\MockRedis
        public: true

    # Service Redis réel pour OrderWatcherPublisher (Pub/Sub)
    App\Provider\Redis\RedisPubSubClient:
        class: Redis
        public: true
        calls:
            - [connect, ['%env(string:REDIS_HOST)%', '%env(int:REDIS_PORT)%']]
        tags:
            - { name: 'container.hot_path' }

    App\MtfValidator\Runtime\Concurrency\LockManager:
        arguments:
            $redis: '@Redis'
            $runtimeLogger: '@monolog.logger.mtf'


    # Rate Limiter

    bitmart.throttle_lock_store:
        class: Symfony\Component\Lock\Store\FlockStore
        arguments:
            - '%kernel.project_dir%/var/lock'

    bitmart.throttle_lock_factory:
        class: Symfony\Component\Lock\LockFactory
        arguments:
            - '@bitmart.throttle_lock_store'

    # Configuration Bitmart
    App\Provider\Bitmart\Http\BitmartConfig:
        arguments:
            $apiKey: '%env(BITMART_API_KEY)%'
            $apiSecret: '%env(BITMART_SECRET_KEY)%'
            $apiMemo: '%env(BITMART_API_MEMO)%'
        public: true
    # Provider pour la configuration des contrats MTF (support par profil avec fallback)
    App\Config\MtfContractsConfigProvider:
        public: true

    # Config par défaut (compatibilité - utilise le fallback)
    App\Config\MtfContractsConfig:
        factory: ['@App\Config\MtfContractsConfigProvider', 'getConfigForProfile']
        arguments: [null]

    # BitMart HTTP Client
    App\Provider\Bitmart\Http\BitmartHttpClientPublic:
        arguments:
            $bitmartFuturesV2: '@http_client.bitmart_futures_v2'
            $bitmartSystem: '@http_client.bitmart_system'
            $lockFactory: '@bitmart.throttle_lock_factory'
            $projectDir: '%kernel.project_dir%'
        public: true

    App\Domain\Ports\Out\TradingProviderPort: '@App\Infrastructure\Trading\BitmartTradingProvider'

    # --- Exchange provider registry ---

    App\Provider\Context\ExchangeContext.bitmart_perpetual:
        class: App\Provider\Context\ExchangeContext
        arguments:
            $exchange: !php/const App\Common\Enum\Exchange::BITMART
            $marketType: !php/const App\Common\Enum\MarketType::PERPETUAL
        public: false

    App\Provider\Context\ExchangeContext.bitmart_spot:
        class: App\Provider\Context\ExchangeContext
        arguments:
            $exchange: !php/const App\Common\Enum\Exchange::BITMART
            $marketType: !php/const App\Common\Enum\MarketType::SPOT
        public: false

    App\Provider\Registry\ExchangeProviderBundle.bitmart_perpetual:
        class: App\Provider\Registry\ExchangeProviderBundle
        arguments:
            $context: '@App\Provider\Context\ExchangeContext.bitmart_perpetual'
            $klineProvider: '@App\Provider\Bitmart\BitmartKlineProvider'
            $contractProvider: '@App\Provider\Bitmart\BitmartContractProvider'
            $orderProvider: '@App\Provider\Bitmart\BitmartOrderProvider'
            $accountProvider: '@App\Provider\Bitmart\BitmartAccountProvider'
            $systemProvider: '@App\Provider\Bitmart\SystemProvider'
        public: false

    # Note: Spot currently reuses the same provider classes. Adjust when spot-specific providers exist.
    App\Provider\Registry\ExchangeProviderBundle.bitmart_spot:
        class: App\Provider\Registry\ExchangeProviderBundle
        arguments:
            $context: '@App\Provider\Context\ExchangeContext.bitmart_spot'
            $klineProvider: '@App\Provider\Bitmart\BitmartKlineProvider'
            $contractProvider: '@App\Provider\Bitmart\BitmartContractProvider'
            $orderProvider: '@App\Provider\Bitmart\BitmartOrderProvider'
            $accountProvider: '@App\Provider\Bitmart\BitmartAccountProvider'
            $systemProvider: '@App\Provider\Bitmart\SystemProvider'
        public: false

    App\Provider\Registry\ExchangeProviderRegistry:
        arguments:
            $bundles:
                - '@App\Provider\Registry\ExchangeProviderBundle.bitmart_perpetual'
                - '@App\Provider\Registry\ExchangeProviderBundle.bitmart_spot'
            $defaultExchange: !php/const App\Common\Enum\Exchange::BITMART
            $defaultMarketType: !php/const App\Common\Enum\MarketType::PERPETUAL

    App\Contract\Provider\ExchangeProviderRegistryInterface: '@App\Provider\Registry\ExchangeProviderRegistry'

    # Provide a default context alias so autowiring of ExchangeContext resolves
    App\Provider\Context\ExchangeContext: '@App\Provider\Context\ExchangeContext.bitmart_perpetual'

    # Kline Provider


    # HTTP Client pour BitMart
    GuzzleHttp\Client:
        arguments:
            - timeout: 10
            - connect_timeout: 5

    # BitMart REST Client (utilise maintenant BitmartHttpClientPublic)
    # App\Infrastructure\Http\BitmartRestClient: supprimé, utilise App\Provider\Bitmart\Http\BitmartHttpClientPublic

    # WebSocket dependencies
    React\EventLoop\LoopInterface:
        class: React\EventLoop\Loop
        factory: [React\EventLoop\Loop, get]

    React\Socket\ConnectorInterface:
        class: React\Socket\Connector
        arguments:
            - loop: '@React\EventLoop\LoopInterface'

    # BitMart WebSocket Client

    # Repositories
    App\Provider\Repository\KlineRepository:
        arguments:
            $registry: '@doctrine'
            $logger: '@logger'

    App\Provider\Repository\ContractRepository:
        arguments:
            $registry: '@doctrine'
            $conn: '@doctrine.dbal.default_connection'
            $configProvider: '@App\Config\MtfContractsConfigProvider'
            $clock: '@Psr\Clock\ClockInterface'

    # Alias pour l'interface de configuration MTF -> implémentation TradingParameters
    App\Config\MtfConfigProviderInterface: '@App\Config\TradingParameters'

    # Config par défaut (compatibilité)
    # Utilise scalper_micro comme config par défaut (mode activé avec priorité la plus élevée)
    App\Config\MtfValidationConfig:
        arguments:
            $path: '%kernel.project_dir%/src/MtfValidator/config/validations.scalper_micro.yaml'

    # Providers pour gérer les modes (regular/scalping)
    App\Config\MtfValidationConfigProvider: ~
    App\Config\TradeEntryConfigProvider: ~

    # Config par défaut (compatibilité)
    App\Config\TradeEntryConfig:
        factory: ['@App\Config\TradeEntryConfigResolver', 'resolve']
        arguments: [null]
        autowire: false

    App\Config\SignalConfig:
        arguments:
            $path: '%kernel.project_dir%/config/app/signal.yaml'
        autowire: false

    App\Config\IndicatorConfig:
        arguments:
            $path: '%kernel.project_dir%/config/app/indicator.yaml'
        autowire: false

    # Registre des conditions: injection automatique via AutowireLocator/AutowireIterator
    App\MtfValidator\ConditionLoader\ConditionRegistry:
        arguments:
            $mtfLogger: '@monolog.logger.mtf'
        calls:
            - [ loadFromConfigs, ['@App\Config\MtfValidationConfig'] ]

    # Nouveau registre des conditions avec AutowireLocator/AutowireIterator
    App\Indicator\Registry\ConditionRegistry:
        arguments:
            $indicatorLogger: '@monolog.logger.indicators'
    App\MtfValidator\ConditionLoader\TimeframeEvaluator:
        arguments:
            $registry: '@App\MtfValidator\ConditionLoader\ConditionRegistry'

    # Execution selector (decide 15m/5m/1m)
    App\MtfValidator\Execution\ExecutionSelector:
        arguments:
            $mtfConfig: '@App\Config\MtfValidationConfig'
            $registry: '@App\MtfValidator\ConditionLoader\ConditionRegistry'

    # Builder de contexte pour les indicateurs
    App\Indicator\Context\IndicatorContextBuilder:
        arguments:
            $rsi: '@App\Indicator\Core\Momentum\Rsi'
            $macd: '@App\Indicator\Core\Momentum\Macd'
            $ema: '@App\Indicator\Core\Trend\Ema'
            $adx: '@App\Indicator\Core\Trend\Adx'
            $vwap: '@App\Indicator\Core\Volume\Vwap'
            $atrCalc: '@App\Indicator\Core\AtrCalculator'
            $sma: '@App\Indicator\Core\Trend\Sma'

    # Contrôleur de test des indicateurs
    App\Indicator\Controller\IndicatorTestController:
        arguments:
            $indicatorMain: '@App\Contract\Indicator\IndicatorMainProviderInterface'
            $tradingConfigService: '@App\Service\TradingConfigService'
            $signalConfig: '@App\Config\SignalConfig'
            $klineDataService: '@App\Service\KlineDataService'
        tags: ['controller.service_arguments']

    # Services pour la configuration et les données
    App\Service\TradingConfigService:
        arguments:
            $parameterBag: '@parameter_bag'
            $tradeEntryConfig: '@App\Config\TradeEntryConfig'

    App\Service\KlineDataService: ~



    # Config Services
    App\Config\TradingParameters:
        arguments:
            $configFile: '%kernel.project_dir%/config/app/trade_entry.yaml'
            $indicatorConfig: '@App\Config\IndicatorConfig'
            $signalConfig: '@App\Config\SignalConfig'
            $tradeEntryConfig: '@App\Config\TradeEntryConfig'

    # Service utilitaire pour le backtesting avec heure fixe
    App\Service\BacktestClockService:
        public: true


    # WebSocket Dispatcher Services
    App\Service\AssignmentStorageInterface: '@App\Service\CsvAssignmentStorage'

    App\Service\CsvAssignmentStorage:
        arguments:
            $filePath: '%kernel.project_dir%/var/hot_assignment.csv'

    # Leverage Service - Dynamic calculation based on stop loss distance
    App\Contract\EntryTrade\LeverageServiceInterface: '@App\TradeEntry\Service\Leverage\DynamicLeverageService'

    # === Handler Monolog qui publie dans Messenger (Async) ===
    # On le rend public pour pouvoir le référencer depuis monolog.yaml (type: service, id: ...)
    App\Indicator\Condition\CloseMinusEma200GtCondition:
        arguments:
            $defaultThreshold: -0.0015   # comme ton YAML
            $eps: 1.0e-12
        tags: ['app.indicator.condition']

    App\Indicator\Condition\CloseMinusEma200LtCondition:
        arguments:
            $defaultThreshold: -0.0015   # ex: exiger close < ema200 de 0,15% ou plus
            $eps: 1.0e-12
        tags: ['app.indicator.condition']

    App\Indicator\Condition\Ema20MinusEma50GtCondition:
        arguments:
            $defaultThreshold: -0.0008   # comme ton YAML
            $eps: 1.0e-12
        tags: ['app.indicator.condition']

    # Formateur de logging personnalisé (service public requis par Monolog)
    App\Logging\CustomLineFormatter:
        public: true

    # === TradeEntry Services ===
    # Les services TradeEntry sont auto-configurés via le namespace `App\` et `autoconfigure`.
    # Plus besoin de l'attribut #[AsService]; ajouter des configs spécifiques si nécessaire.

    # Configuration TradeEntry avec paramètres par défaut
    # App\TradeEntry\PreOrder\PreOrderBuilder:
    #     arguments:
    #         $defaults: '%trade_entry.defaults%'

    # Logger spécifique pour TradeEntry
    monolog.logger.trade_entry:
        parent: monolog.logger
        arguments:
            - trade_entry
        tags:
            - { name: monolog.logger, channel: trade_entry }

    # Logger spécifique pour Bitmart (HTTP public/privé)
    monolog.logger.bitmart:
        parent: monolog.logger
        arguments:
            - bitmart
        tags:
            - { name: monolog.logger, channel: bitmart }

    monolog.logger.ws_agent:
        parent: monolog.logger
        arguments:
            - ws_agent
        tags:
            - { name: monolog.logger, channel: ws_agent }

    # WebSocket Dispatcher (configuration explicite pour résoudre l'injection)
    App\WebSocket\Service\WsDispatcher:
        arguments:
            $wsPublicKlinesService: '@App\WebSocket\Service\WsPublicKlinesService'
            $logger: '@logger'

    # === Trading Storage Services ===
    # Alias pour les interfaces de repository
    App\Trading\Storage\PositionStateRepositoryInterface: '@App\Trading\Storage\PositionPositionStateRepository'
    App\Trading\Storage\OrderStateRepositoryInterface: '@App\Trading\Storage\FuturesOrderOrderStateRepository'

    # TradingStateSyncRunner - utilise les providers depuis MainProvider
    App\Trading\Sync\TradingStateSyncRunner:
        arguments:
            $mainProvider: '@App\Contract\Provider\MainProviderInterface'

    # Logger spécifique pour Trading
    monolog.logger.trading:
        parent: monolog.logger
        arguments:
            - trading
        tags:
            - { name: monolog.logger, channel: trading }

    # Listener PositionClosedLoggerListener avec logger spécifique
    App\Trading\Listener\PositionClosedLoggerListener:
        arguments:
            $tradingLogger: '@monolog.logger.trading'
