Index: symfony-app/src/Service/Trading/OpenedLockedSyncService.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\nnamespace App\\Service\\Trading;\n\nuse App\\Entity\\ContractPipeline;\nuse App\\Repository\\ContractPipelineRepository;\nuse App\\Service\\Bitmart\\Private\\PositionsService;\nuse App\\Service\\Bitmart\\Private\\OrdersService;\nuse Doctrine\\ORM\\EntityManagerInterface;\n\nfinal class OpenedLockedSyncService\n{\n    public function __construct(\n        private readonly PositionsService $positionsService,\n        private readonly OrdersService $ordersService,\n        private readonly ContractPipelineRepository $repo,\n        private readonly EntityManagerInterface $em\n    ) {}\n    /** @var array<string, array<int, array<string, mixed>>> */\n    private array $openOrdersCache = [];\n\n    /**\n     * 1) Récupère les positions ouvertes sur BitMart (symboles avec qty != 0).\n     * 2) Liste les pipelines en OPENED_LOCKED.\n     * 3) Déverrouille (status -> pending) ceux qui ne sont plus ouverts.\n     *\n     * @return array{\n     *   bitmart_open_symbols:string[],\n     *   locked_symbols_before:string[],\n     *   removed_symbols:string[],\n     *   kept_symbols:string[],\n     *   cleared_order_ids:string[],\n     *   total_unlocked:int\n     * }\n     */\n    public function sync(): array\n    {\n        // (1) Symboles effectivement ouverts chez BitMart\n        $bm = $this->positionsService->list();\n        $openSymbols = [];\n        foreach (($bm['data'] ?? []) as $pos) {\n            $qty = (float)($pos['current_amount'] ?? 0);\n            if ($qty !== 0.0) {\n                $openSymbols[] = strtoupper((string)$pos['symbol']);\n            }\n        }\n        $openSymbols = array_values(array_unique($openSymbols));\n\n        // (2) Pipelines OPENED_LOCKED\n        $lockedPipelines = $this->repo->findAllOpenedLocked();\n        $lockedSymbolsBefore = [];\n        foreach ($lockedPipelines as $p) {\n            $lockedSymbolsBefore[] = strtoupper($p->getContract()->getSymbol());\n        }\n\n        // (3) Déverrouiller ceux qui ne sont plus ouverts côté BitMart\n        $removed = [];\n        $kept = [];\n        $clearedOrderIds = [];\n        $requiresFlush = false;\n\n        foreach ($lockedPipelines as $pipeline) {\n            $sym = strtoupper($pipeline->getContract()->getSymbol());\n            $orderId = $pipeline->getOrderId();\n            $orderStillOpen = $orderId ? $this->isOrderStillOpen($sym, $orderId) : false;\n\n            if (!in_array($sym, $openSymbols, true) && !$orderStillOpen) {\n                // ⇒ position fermée et aucun ordre actif : on relâche la pipeline\n                $pipeline->setStatus(ContractPipeline::STATUS_PENDING)->setCurrentTimeframe('15m');\n                $this->em->persist($pipeline);\n                $removed[] = $sym;\n                if ($orderId !== null) {\n                    $clearedOrderIds[] = $sym;\n                }\n                $requiresFlush = true;\n            } else {\n                if ($orderId !== null && !$orderStillOpen) {\n                    // Ordre annulé ou exécuté, on efface la référence locale\n                    $pipeline->setOrderId(null);\n                    $this->em->persist($pipeline);\n                    $clearedOrderIds[] = $sym;\n                    $requiresFlush = true;\n                }\n                $kept[] = $sym;\n            }\n        }\n\n        if ($requiresFlush) {\n            $this->em->flush();\n        }\n\n        return [\n            'bitmart_open_symbols' => $openSymbols,\n            'locked_symbols_before' => array_values(array_unique($lockedSymbolsBefore)),\n            'removed_symbols' => array_values(array_unique($removed)), // ceux qu’on a “sortis du tableau”\n            'kept_symbols' => array_values(array_unique($kept)),       // ceux qui restent OPENED_LOCKED\n            'cleared_order_ids' => array_values(array_unique($clearedOrderIds)),\n            'total_unlocked' => count($removed),\n        ];\n    }\n\n    private function isOrderStillOpen(string $symbol, string $orderId): bool\n    {\n        if ($orderId === '') {\n            return false;\n        }\n\n        if (!array_key_exists($symbol, $this->openOrdersCache)) {\n            try {\n                $response = $this->ordersService->open(['symbol' => $symbol]);\n            } catch (\\Throwable) {\n                // Impossible de déterminer, on suppose que l'ordre reste actif.\n                return true;\n            }\n\n            $orders = $this->normalizeOrders($response['orders'] ?? []);\n            $planOrders = $this->normalizeOrders($response['plan_orders'] ?? []);\n            $this->openOrdersCache[$symbol] = array_merge($orders, $planOrders);\n        }\n\n        foreach ($this->openOrdersCache[$symbol] as $order) {\n            if (!is_array($order)) {\n                continue;\n            }\n\n            $matchesOrderId = isset($order['order_id']) && (string) $order['order_id'] === $orderId;\n            $matchesClientOrderId = isset($order['client_order_id']) && (string) $order['client_order_id'] === $orderId;\n            $matchesClientOid = isset($order['client_oid']) && (string) $order['client_oid'] === $orderId;\n\n            if ($matchesOrderId || $matchesClientOrderId || $matchesClientOid) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @return array<int, array<string, mixed>>\n     */\n    private function normalizeOrders(array $response): array\n    {\n        if (isset($response['data']) && is_array($response['data'])) {\n            return $this->normalizeOrders($response['data']);\n        }\n\n        if ($this->isList($response)) {\n            return array_filter($response, 'is_array');\n        }\n\n        if (isset($response['orders']) && is_array($response['orders'])) {\n            return $this->normalizeOrders($response['orders']);\n        }\n\n        $orders = [];\n        foreach ($response as $entry) {\n            if (is_array($entry) && (isset($entry['order_id']) || isset($entry['client_order_id']) || isset($entry['client_oid']))) {\n                $orders[] = $entry;\n            }\n        }\n\n        return $orders;\n    }\n\n    private function isList(array $array): bool\n    {\n        if (function_exists('array_is_list')) {\n            return array_is_list($array);\n        }\n\n        $expectedKey = 0;\n        foreach ($array as $key => $_) {\n            if ($key !== $expectedKey) {\n                return false;\n            }\n            $expectedKey++;\n        }\n        return true;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Service/Trading/OpenedLockedSyncService.php b/symfony-app/src/Service/Trading/OpenedLockedSyncService.php
--- a/symfony-app/src/Service/Trading/OpenedLockedSyncService.php	(revision acfe8edc4f51e920bc6e35643a19748aa79bb144)
+++ b/symfony-app/src/Service/Trading/OpenedLockedSyncService.php	(date 1759597569449)
@@ -3,7 +3,9 @@
 namespace App\Service\Trading;
 
 use App\Entity\ContractPipeline;
+use App\Entity\Position;
 use App\Repository\ContractPipelineRepository;
+use App\Repository\PositionRepository;
 use App\Service\Bitmart\Private\PositionsService;
 use App\Service\Bitmart\Private\OrdersService;
 use Doctrine\ORM\EntityManagerInterface;
@@ -14,6 +16,7 @@
         private readonly PositionsService $positionsService,
         private readonly OrdersService $ordersService,
         private readonly ContractPipelineRepository $repo,
+        private readonly PositionRepository $positionRepo,
         private readonly EntityManagerInterface $em
     ) {}
     /** @var array<string, array<int, array<string, mixed>>> */
@@ -35,17 +38,35 @@
      */
     public function sync(): array
     {
-        // (1) Symboles effectivement ouverts chez BitMart
+        // (1) Symboles effectivement ouverts chez BitMart + mise à jour SL/TP
         $bm = $this->positionsService->list();
         $openSymbols = [];
+        $positionsToUpdate = []; // [symbol => [sl, tp]]
+
         foreach (($bm['data'] ?? []) as $pos) {
             $qty = (float)($pos['current_amount'] ?? 0);
             if ($qty !== 0.0) {
-                $openSymbols[] = strtoupper((string)$pos['symbol']);
+                $symbol = strtoupper((string)$pos['symbol']);
+                $openSymbols[] = $symbol;
+
+                // Récupérer SL et TP depuis l'API BitMart
+                $sl = isset($pos['stop_loss_price']) && $pos['stop_loss_price'] !== ''
+                    ? (string)$pos['stop_loss_price']
+                    : null;
+                $tp = isset($pos['take_profit_price']) && $pos['take_profit_price'] !== ''
+                    ? (string)$pos['take_profit_price']
+                    : null;
+
+                if ($sl !== null || $tp !== null) {
+                    $positionsToUpdate[$symbol] = ['sl' => $sl, 'tp' => $tp];
+                }
             }
         }
         $openSymbols = array_values(array_unique($openSymbols));
 
+        // Mettre à jour les positions en BDD avec les SL/TP
+        $this->updatePositionsSlTp($positionsToUpdate);
+
         // (2) Pipelines OPENED_LOCKED
         $lockedPipelines = $this->repo->findAllOpenedLocked();
         $lockedSymbolsBefore = [];
@@ -177,4 +198,53 @@
         }
         return true;
     }
+
+    /**
+     * Met à jour les SL/TP des positions ouvertes en BDD depuis les données BitMart
+     * @param array<string, array{sl: ?string, tp: ?string}> $positionsData
+     */
+    private function updatePositionsSlTp(array $positionsData): void
+    {
+        if (empty($positionsData)) {
+            return;
+        }
+
+        $requiresFlush = false;
+
+        foreach ($positionsData as $symbol => $data) {
+            // Récupérer la position OPEN pour ce symbole
+            $position = $this->positionRepo->createQueryBuilder('p')
+                ->innerJoin('p.contract', 'c')
+                ->where('UPPER(c.symbol) = :symbol')
+                ->andWhere('p.status = :status')
+                ->setParameter('symbol', strtoupper($symbol))
+                ->setParameter('status', Position::STATUS_OPEN)
+                ->setMaxResults(1)
+                ->getQuery()
+                ->getOneOrNullResult();
+
+            if ($position) {
+                $updated = false;
+
+                if ($data['sl'] !== null && $position->getStopLoss() !== $data['sl']) {
+                    $position->setStopLoss($data['sl']);
+                    $updated = true;
+                }
+
+                if ($data['tp'] !== null && $position->getTakeProfit() !== $data['tp']) {
+                    $position->setTakeProfit($data['tp']);
+                    $updated = true;
+                }
+
+                if ($updated) {
+                    $this->em->persist($position);
+                    $requiresFlush = true;
+                }
+            }
+        }
+
+        if ($requiresFlush) {
+            $this->em->flush();
+        }
+    }
 }
Index: symfony-app/src/Repository/ContractPipelineRepository.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\nnamespace App\\Repository;\n\nuse App\\Entity\\ContractPipeline;\nuse Doctrine\\Bundle\\DoctrineBundle\\Repository\\ServiceEntityRepository;\nuse Doctrine\\Persistence\\ManagerRegistry;\n\nclass ContractPipelineRepository extends ServiceEntityRepository\n{\n    public function __construct(ManagerRegistry $registry)\n    {\n        parent::__construct($registry, ContractPipeline::class);\n    }\n\n\n    /**\n     * Retourne tous les pipelines au statut OPENED_LOCKED.\n     * @return ContractPipeline[]\n     */\n    public function findAllOpenedLocked(): array\n    {\n        return $this->createQueryBuilder('p')\n            ->andWhere('p.status = :st')->setParameter('st', ContractPipeline::STATUS_OPENED_LOCKED)\n            ->getQuery()\n            ->getResult();\n    }\n\n    /**\n     * Retourne les symboles (string[]) au statut OPENED_LOCKED.\n     * Utilise la relation vers Contract(symbol).\n     * @return string[]\n     */\n    public function getAllSymbolsOpenedLocked(): array\n    {\n        $rows = $this->createQueryBuilder('p')\n            ->innerJoin('p.contract', 'c')\n            ->select('c.symbol AS symbol')\n            ->andWhere('p.status = :st')->setParameter('st', ContractPipeline::STATUS_OPENED_LOCKED)\n            ->getQuery()\n            ->getResult();\n\n        return array_map(static fn(array $r) => $r['symbol'], $rows) ?? [];\n    }\n\n\n    /**\n     * Retourne les contrats éligibles à un timeframe donné (pending) avec un cap de résultats.\n     */\n    public function findEligibleFor(string $timeframe, int $limit = 500): array\n    {\n        return $this->createQueryBuilder('p')\n            ->andWhere('p.currentTimeframe = :tf')->setParameter('tf', $timeframe)\n            ->andWhere('p.status = :st')->setParameter('st', ContractPipeline::STATUS_PENDING)\n            ->orderBy('p.updatedAt', 'ASC')\n            ->setMaxResults($limit)\n            ->getQuery()\n            ->getResult();\n    }\n\n    public function getAllSymbolsWithActive4h(): array\n    {\n        return $this->getAllSymbolsWithActiveTimeframe('4h');\n    }\n\n    /**\n     * Met à jour l'orderId pour un symbole donné\n     */\n    public function updateOrderIdBySymbol(string $symbol, string $orderId): void\n    {\n        $this->createQueryBuilder('p')\n            ->update()\n            ->set('p.orderId', ':orderId')\n            ->where('IDENTITY(p.contract) = :symbol')\n            ->setParameter('orderId', $orderId)\n            ->setParameter('symbol', $symbol)\n            ->getQuery()\n            ->execute();\n    }\n\n    public function getAllSymbolsWithActive1h(): array\n    {\n        return $this->getAllSymbolsWithActiveTimeframe('1h');\n    }\n\n    public function getAllSymbolsWithActive15m(): array\n    {\n        return $this->getAllSymbolsWithActiveTimeframe('15m');\n    }\n\n    public function getAllSymbolsWithActive5m(): array\n    {\n        return $this->getAllSymbolsWithActiveTimeframe('5m');\n    }\n\n    public function getAllSymbolsWithActive1m(): array\n    {\n        return $this->getAllSymbolsWithActiveTimeframe('1m');\n    }\n\n    public function getAllSymbolsWithActiveTimeframe(string $timeframe, int $limit = 221): array\n    {\n        $result = $this->createQueryBuilder('p')\n            ->innerJoin('p.contract', 'c')\n            ->select('c.symbol AS contractSymbol')\n            ->where('p.currentTimeframe = :tf')->setParameter('tf', $timeframe)\n            ->andWhere('p.status != :locked')->setParameter('locked', ContractPipeline::STATUS_OPENED_LOCKED)\n            ->andWhere('p.status != :locked2')->setParameter('locked2', ContractPipeline::STATUS_ORDER_OPENED)\n            ->andWhere('p.orderId IS NULL')\n            ->setMaxResults($limit)\n            ->getQuery()\n            ->getResult();\n        return array_map(fn($item) => $item['contractSymbol'], $result) ?? [];\n    }\n\n    public function getAllSymbols(): array\n    {\n        $result = $this->createQueryBuilder('p')\n            ->join('p.contract', 'c')\n            ->select('c.symbol AS contractId')\n            ->where('p.currentTimeframe != :tf')->setParameter('tf', '4h')\n            ->getQuery()\n            ->getResult();\n\n        return array_map(fn($item) => $item['contractId'], $result) ?? [];\n    }\n\n    public function updateStatusBySymbol(string $symbol, string $status): int\n    {\n        return $this->createQueryBuilder('p')\n            ->update()\n            ->set('p.status', ':status')\n            ->where('IDENTITY(p.contract) = :symbol')\n            ->setParameter('status', $status)\n            ->setParameter('symbol', $symbol)\n            ->getQuery()\n            ->execute();\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Repository/ContractPipelineRepository.php b/symfony-app/src/Repository/ContractPipelineRepository.php
--- a/symfony-app/src/Repository/ContractPipelineRepository.php	(revision acfe8edc4f51e920bc6e35643a19748aa79bb144)
+++ b/symfony-app/src/Repository/ContractPipelineRepository.php	(date 1759593035935)
@@ -106,7 +106,7 @@
             ->where('p.currentTimeframe = :tf')->setParameter('tf', $timeframe)
             ->andWhere('p.status != :locked')->setParameter('locked', ContractPipeline::STATUS_OPENED_LOCKED)
             ->andWhere('p.status != :locked2')->setParameter('locked2', ContractPipeline::STATUS_ORDER_OPENED)
-            ->andWhere('p.orderId IS NULL')
+            ->andWhere('p.orderId IS NULL or p.orderId = \'\'')
             ->setMaxResults($limit)
             ->getQuery()
             ->getResult();
@@ -115,6 +115,8 @@
 
     public function getAllSymbols(): array
     {
+
+
         $result = $this->createQueryBuilder('p')
             ->join('p.contract', 'c')
             ->select('c.symbol AS contractId')
@@ -137,4 +139,17 @@
             ->execute();
     }
 
+    /**
+     * Retourne un ContractPipeline par symbole de contrat ou null s'il n'existe pas
+     */
+    public function findBySymbol(string $symbol): ?ContractPipeline
+    {
+        return $this->createQueryBuilder('cp')
+            ->join('cp.contract', 'c')
+            ->andWhere('c.symbol = :symbol')
+            ->setParameter('symbol', $symbol)
+            ->getQuery()
+            ->getOneOrNullResult();
+    }
+
 }
Index: symfony-app/src/Service/Bitmart/Private/OrdersService.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Service\\Bitmart\\Private;\n\nuse App\\Bitmart\\Http\\BitmartHttpClientPrivate;\n\nfinal class OrdersService\n{\n    public function __construct(\n        private readonly BitmartHttpClientPrivate $client,\n    ) {}\n\n    /**\n     * Créer un ordre. Idempotence stricte via client_order_id.\n     * @param array<string,mixed> $params\n     * @return array<mixed>\n     */\n    public function create(array $params): array\n    {\n        // POST /contract/private/submit-order\n        return $this->client->request('POST', '/contract/private/submit-order', [], $params);\n    }\n\n    /**\n     * Annuler un ordre par order_id ou client_order_id.\n     * @param array<string,mixed> $params\n     */\n    public function cancel(array $params): array\n    {\n        // POST /contract/private/cancel-order\n        return $this->client->request('POST', '/contract/private/cancel-order', [], $params);\n    }\n\n    /**\n     * Historique des ordres\n     * @param array<string,mixed> $query\n     */\n    public function history(array $query = []): array\n    {\n        // GET /contract/private/order-history-v2\n        return $this->client->request('GET', '/contract/private/order-history-v2', $query);\n    }\n\n    /**\n     * Liste les ordres ouverts (GET /contract/private/get-open-orders)\n     * @param array<string,mixed> $query\n     */\n    public function open(array $query = []): array\n    {\n        $openOrders = $this->client->request('GET', '/contract/private/get-open-orders', $query);\n\n        $currentPlan = [];\n        try {\n            $currentPlan = $this->client->request('GET', '/contract/private/current-plan-order', $query);\n        } catch (\\Throwable $e) {\n            // certains tenants peuvent ne pas supporter l'endpoint plan; on ignore\n        }\n\n        return [\n            'orders' => $openOrders['data']['orders'] ?? $openOrders['data'] ?? [],\n            'plan_orders' => $currentPlan['data']['orders'] ?? $currentPlan['data'] ?? [],\n        ];\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Service/Bitmart/Private/OrdersService.php b/symfony-app/src/Service/Bitmart/Private/OrdersService.php
--- a/symfony-app/src/Service/Bitmart/Private/OrdersService.php	(revision acfe8edc4f51e920bc6e35643a19748aa79bb144)
+++ b/symfony-app/src/Service/Bitmart/Private/OrdersService.php	(date 1759597040652)
@@ -5,11 +5,19 @@
 namespace App\Service\Bitmart\Private;
 
 use App\Bitmart\Http\BitmartHttpClientPrivate;
+use App\Entity\Order;
+use App\Enum\OrderType;
+use App\Enum\Side;
+use App\Repository\ContractPipelineRepository;
+use App\Service\Exchange\Bitmart\Dto\SubmitOrderRequestDto;
+use App\Service\Exchange\Bitmart\Dto\SubmitOrderResponseDto;
+use App\Service\Trading\OrderHydrator;
 
 final class OrdersService
 {
     public function __construct(
         private readonly BitmartHttpClientPrivate $client,
+        private readonly ContractPipelineRepository $pipelineRepository,
     ) {}
 
     /**
Index: symfony-app/src/Controller/Bitmart/KlinesCallbackController.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\nnamespace App\\Controller\\Bitmart;\n\nuse App\\Bitmart\\Http\\BitmartHttpClientPublic;\nuse App\\Entity\\Contract;\nuse App\\Entity\\ContractPipeline;\nuse App\\Repository\\ContractPipelineRepository;\nuse App\\Repository\\KlineRepository;\nuse App\\Service\\Exception\\Trade\\Position\\LeverageLowException;\nuse App\\Service\\Persister\\KlinePersister;\nuse App\\Service\\Pipeline\\ContractPipelineService;\nuse App\\Service\\Signals\\Timeframe\\SignalService;\nuse App\\Service\\Trading\\PositionOpener;\nuse App\\Service\\Trading\\BitmartAccountGateway;\nuse App\\Service\\Bitmart\\BitmartRefreshService;\nuse App\\Service\\ContractSignalWriter;\nuse App\\Service\\Signals\\HighConviction\\HighConvictionMetricsBuilder;\nuse App\\Service\\Strategy\\HighConvictionValidation;\nuse App\\Service\\Strategy\\HighConvictionTraceWriter;\nuse App\\Repository\\RuntimeGuardRepository;\nuse App\\Util\\TimeframeHelper;\nuse Doctrine\\ORM\\EntityManagerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\n\nfinal class KlinesCallbackController extends AbstractController\n{\n    private const LIMIT_KLINES = 270; // fallback si non fourni\n\n    private readonly HighConvictionValidation $highConviction;\n    private readonly BitmartAccountGateway $bitmartAccount;\n    private readonly HighConvictionTraceWriter $hcTraceWriter;\n\n    public function __construct(\n        // Services et repos conservés\n        private readonly EntityManagerInterface $em,\n        private readonly ContractPipelineService $pipelineService,\n        private readonly ContractSignalWriter $contractSignalWriter,\n        private readonly KlineRepository $klineRepository,\n        private readonly PositionOpener $positionOpener,\n        private readonly RuntimeGuardRepository $runtimeGuardRepository,\n        private readonly ContractPipelineRepository $contractPipelineRepository,\n        private readonly HighConvictionMetricsBuilder $hcMetricsBuilder,\n        HighConvictionValidation $highConviction,\n        HighConvictionTraceWriter $hcTraceWriter,\n        BitmartAccountGateway $bitmartAccount,\n\n        // ⬇\uFE0F Remplacement BitmartFetcher → client public REST\n        private readonly BitmartHttpClientPublic $bitmart,\n\n        // Persistance klines via upsert bulk MySQL\n        private readonly KlinePersister $persister,\n\n        // Logs\n        private readonly LoggerInterface $logger,\n        private readonly LoggerInterface $validationLogger,\n\n        // Ton service d’évaluation (existant)\n        private readonly SignalService $signalService,\n        private readonly BitmartRefreshService $refreshService,\n    ) {\n        $this->highConviction = $highConviction;\n        $this->bitmartAccount = $bitmartAccount;\n        $this->hcTraceWriter = $hcTraceWriter;\n    }\n\n    #[Route('/api/callback/bitmart/get-kline', name: 'bitmart_klines_callback', methods: ['POST'])]\n    public function __invoke(Request $request): JsonResponse\n    {\n        if ($this->runtimeGuardRepository->isPaused()) {\n            return new JsonResponse(['status' => 'paused'], 200);\n        }\n\n        $envelope = json_decode($request->getContent(), true) ?? [];\n        $payload  = $envelope['params'] ?? [];\n\n        $symbol    = (string) ($payload['contract']  ?? '');\n        $timeframe = strtolower((string) ($payload['timeframe'] ?? '4h'));\n        $limit     = (int)    ($payload['limit']     ?? self::LIMIT_KLINES);\n\n        if ($symbol === '') {\n            return $this->jsonError('Missing contract symbol', 400);\n        }\n\n        /** @var Contract|null $contract */\n        $contract = $this->em->getRepository(Contract::class)->findOneBy(['symbol' => $symbol]);\n        if (!$contract) {\n            return $this->jsonError('Contract not found: '.$symbol, 404);\n        }\n\n        // Normalise le pas → minutes (Futures V2 attend des minutes côté REST)\n        $stepMinutes = TimeframeHelper::parseTimeframeToMinutes($timeframe);\n\n        // 1) Fetch : N DERNIÈRES bougies CLÔTURÉES (exclut la bougie en cours)\n        $klinesDto = $this->bitmart->getFuturesKlines(\n            symbol: $symbol,\n            step:   $stepMinutes,\n            fromTs: null,\n            toTs:   null,\n            limit:  $limit\n        );\n\n        // 2) Persist (upsert bulk, clé unique (contract_id, timestamp, step))\n        $affected = $this->persister->upsertMany($contract, $stepMinutes, $klinesDto);\n\n        // 3) Recharge un lookback suffisant (closes) pour l’évaluation\n        $lookback = max(260, $limit);\n        $klines   = $this->klineRepository->findRecentBySymbolAndTimeframe(\n            $contract->getSymbol(),\n            $timeframe,\n            $lookback\n        );\n        $klines   = array_values($klines);\n\n        // Log de contrôle: compare la dernière kline persistée à l'ouverture de l'intervalle courant (cutoff)\n        $cutoff = TimeframeHelper::getAlignedOpenByMinutes($stepMinutes);\n        $lastPersisted = null;\n        if ($klines) {\n            $last = $klines[count($klines) - 1];\n            $lastPersisted = method_exists($last, 'getTimestamp') ? $last->getTimestamp() : null;\n        }\n        $this->logger->info('Klines cutoff control', [\n            'symbol' => $symbol,\n            'timeframe' => $timeframe,\n            'step_minutes' => $stepMinutes,\n            'cutoff_ts' => $cutoff->getTimestamp(),\n            'cutoff' => $cutoff->format('Y-m-d H:i:s'),\n            'last_persisted_ts' => $lastPersisted ? $lastPersisted->getTimestamp() : null,\n            'last_persisted' => $lastPersisted ? $lastPersisted->format('Y-m-d H:i:s') : null,\n            'has_non_closed' => $lastPersisted ? ($lastPersisted->getTimestamp() >= $cutoff->getTimestamp()) : null,\n            'persisted_count' => count($klines),\n        ]);\n\n        // Si la dernière kline persistée est plus vieille que now - timeframe, on relance un refresh et on skip\n        $now = new \\DateTimeImmutable('now', new \\DateTimeZone('UTC'));\n        $staleThreshold = $now->modify('-'.$stepMinutes.' minutes');\n        if ($lastPersisted && $lastPersisted < $staleThreshold) {\n            $this->logger->warning('Last kline is stale, triggering refresh and skipping evaluation', [\n                'symbol' => $symbol,\n                'timeframe' => $timeframe,\n                'last_persisted' => $lastPersisted->format('Y-m-d H:i:s'),\n                'threshold' => $staleThreshold->format('Y-m-d H:i:s'),\n            ]);\n            $this->refreshService->refreshSingle($symbol, $timeframe, $limit);\n            return new JsonResponse([\n                'status' => 'refreshed',\n                'reason' => 'stale_last_kline',\n                'symbol' => $symbol,\n                'timeframe' => $timeframe,\n            ], 202);\n        }\n\n        // 4) Récupère signaux existants (compat avec anciens champs)\n        $existingPipeline = $this->em\n            ->getRepository(ContractPipeline::class)\n            ->findOneBy(['contract' => $contract]);\n\n        $knownSignals = [];\n        if ($existingPipeline) {\n            $sig = $existingPipeline->getSignals() ?? [];\n            foreach (['4h','1h','15m','5m'] as $tf) {\n                if (isset($sig[$tf]['signal'])) { $knownSignals[$tf] = $sig[$tf]; }\n            }\n            $mapCompat = ['context_4h'=>'4h','context_1h'=>'1h','exec_15m'=>'15m','exec_5m'=>'5m','micro_1m'=>'1m'];\n            foreach ($mapCompat as $k => $tf) {\n                if (!isset($knownSignals[$tf]) && isset($sig[$k]['signal'])) { $knownSignals[$tf] = $sig[$k]; }\n            }\n        }\n\n        // 5) Évalue le TF courant\n        $result = $this->signalService->evaluate($timeframe, $klines, $knownSignals);\n\n        $signalsPayload = $result['signals'] ?? [];\n        $signalsPayload[$timeframe] = $signalsPayload[$timeframe] ?? ['signal' => 'NONE'];\n        $signalsPayload['final']  = $result['final']  ?? ['signal' => 'NONE'];\n        $signalsPayload['status'] = $result['status'] ?? 'UNKNOWN';\n\n        // 6) Sauvegarde des signaux + plage (from/to klines présents)\n        $pipeline = $this->contractSignalWriter->saveAttempt(\n            contract: $contract,\n            tf: $timeframe,\n            signals: $signalsPayload,\n            flush: false\n        );\n\n        $fromKline = $klines ? $klines[0] : null;\n        $toKline   = $klines ? $klines[\\count($klines)-1] : null;\n        if ($pipeline && $fromKline && $toKline) {\n            $pipeline->setKlineRange($fromKline, $toKline);\n        }\n\n        $this->validationLogger->info(' --- END Evaluating signal '.$timeframe.' --- ');\n        $this->validationLogger->info('signals.payload', [\n            'symbol' => $symbol,\n            'timeframe' => $timeframe,\n            'signal' => $signalsPayload[$timeframe]['signal'] ?? 'NONE',\n            'signals' => array_map(\n                static fn($signal, $key) => \"$key => \" . ($signal['signal'] ?? 'NONE'),\n                $pipeline ? $pipeline->getSignals() : [],\n                array_keys($pipeline ? $pipeline->getSignals() : [])\n            ),\n            'final_signal' => $signalsPayload['final']['signal'] ?? 'NONE',\n            'status' => $signalsPayload['status'] ?? null,\n        ]);\n\n        // 7) Décision MTF + ouverture éventuelle\n        $signal = $signalsPayload['signal'] ?? $signalsPayload['final']['signal'] ?? 'NONE';\n        if ($pipeline && !($timeframe === '4h' && $signal === 'NONE')) {\n            $contextTrail = [];\n\n            // a) Marque tentative & applique décision\n            $this->pipelineService->markAttempt($pipeline);\n            $isValid = $this->pipelineService->applyDecision($pipeline, $timeframe);\n            $contextTrail[] = ['step' => 'decision_applied', 'timeframe' => $timeframe, 'is_valid' => $isValid];\n\n            // b) Logs décision\n            $this->validationLogger->info('Position decision', [\n                'symbol' => $symbol,\n                'timeframe' => $timeframe,\n                'is_valid' => $isValid,\n                'signal' => $signalsPayload[$timeframe]['signal'] ?? 'NONE',\n                'signals' => array_map(\n                    static fn($signal, $key) => \"$key => \" . ($signal['signal'] ?? 'NONE'),\n                    $pipeline->getSignals(),\n                    array_keys($pipeline->getSignals())\n                ),\n                'final_signal' => $signalsPayload['final']['signal'] ?? 'NONE',\n                'status' => $signalsPayload['status'] ?? null,\n                'trail'  => $contextTrail,\n            ]);\n\n            // c) Fenêtre d'ouverture (dernier TF seulement)\n            $tfOpenable = ['1m'];\n            if ($isValid && in_array($timeframe, $tfOpenable, true)) {\n                $contextTrail[] = ['step' => 'window_eligible'];\n                $this->validationLogger->info('Window eligible for order opening', [\n                    'symbol' => $symbol,\n                    'timeframe' => $timeframe,\n                    'trail' => $contextTrail,\n                ]);\n                $finalSide = strtoupper($signalsPayload['final']['signal'] ?? 'NONE');\n\n                if (\\in_array($finalSide, ['LONG','SHORT'], true)) {\n                    $contextTrail[] = ['step' => 'final_side', 'side' => $finalSide];\n                    $this->validationLogger->info('Final decision side confirmed', [\n                        'symbol' => $symbol,\n                        'timeframe' => $timeframe,\n                        'side' => $finalSide,\n                        'trail' => $contextTrail,\n                    ]);\n                    $ctx = $pipeline->getSignals() ?? [];\n\n                    try {\n                        $built = $this->hcMetricsBuilder->buildForSymbol(\n                            symbol:     $symbol,\n                            signals:    $ctx,\n                            sideUpper:  $finalSide,\n                            entry:      $limit ?? null,   // si tu utilises déjà un prix/limit ailleurs\n                            riskMaxPct: 0.07,\n                            rMultiple:  2.0\n                        );\n                        $metrics = $built['metrics'];\n                    } catch (\\Throwable $e) {\n                        $this->validationLogger->warning('HC metrics builder failed, skipping order', [\n                            'symbol' => $symbol,\n                            'timeframe' => $timeframe,\n                            'error' => $e->getMessage(),\n                            'trail' => $contextTrail,\n                        ]);\n                        $metrics = null;\n                    }\n\n                    if ($metrics === null) {\n                        $contextTrail[] = ['step' => 'metrics_failed'];\n                        goto pipeline_lock;\n                    }\n\n                    $hc       = $this->highConviction->validate($ctx, $metrics);\n                    $isHigh   = (bool)($hc['ok'] ?? false);\n                    $levCap   = (int)($hc['flags']['leverage_cap'] ?? 0);\n                    $contextTrail[] = ['step' => 'hc_result', 'is_high' => $isHigh, 'leverage_cap' => $levCap];\n\n                    $this->validationLogger->info('HighConviction evaluation', [\n                        'ok'      => $isHigh,\n                        'flags'   => $hc['flags']   ?? null,\n                        'reasons' => $hc['reasons'] ?? null,\n                        'trail'   => $contextTrail,\n                    ]);\n\n                    $this->hcTraceWriter->record([\n                        'symbol'       => $symbol,\n                        'timeframe'    => $timeframe,\n                        'evaluated_at' => (new \\DateTimeImmutable('now', new \\DateTimeZone('UTC')))->format(DATE_ATOM),\n                        'signals'      => $ctx,\n                        'metrics'      => $metrics,\n                        'validation'   => $hc,\n                        'trail'        => $contextTrail,\n                    ]);\n                    $this->validationLogger->info('HighConviction trace recorded', [\n                        'symbol' => $symbol,\n                        'timeframe' => $timeframe,\n                    ]);\n\n                    if ($isHigh && $levCap > 0) {\n                        $availableUsdt = $this->bitmartAccount->getAvailableUSDT();\n                        $marginBudget  = max(0.0, $availableUsdt * 0.5);\n                        $contextTrail[] = [\n                            'step' => 'budget_high_conviction',\n                            'available_usdt' => $availableUsdt,\n                            'margin_usdt' => $marginBudget,\n                        ];\n\n                        if ($marginBudget <= 0.0) {\n                            $contextTrail[] = ['step' => 'budget_insufficient'];\n                            $this->validationLogger->warning('Skipping HC opening: available balance is zero', [\n                                'symbol' => $symbol,\n                                'available_usdt' => $availableUsdt,\n                                'trail' => $contextTrail,\n                            ]);\n                            goto pipeline_lock;\n                        }\n\n                        $contextTrail[] = ['step' => 'opening_high_conviction'];\n                        $this->validationLogger->info('Opening position [HIGH_CONVICTION]', [\n                            'symbol'       => $symbol,\n                            'final_side'   => $finalSide,\n                            'leverage_cap' => $levCap,\n                            'signal'       => $signalsPayload[$timeframe] ?? null,\n                            'trail'        => $contextTrail,\n                        ]);\n\n                        try {\n                            $this->positionOpener->openLimitHighConvWithSr(\n                                symbol:         $symbol,\n                                finalSideUpper: $finalSide,\n                                leverageCap:    $levCap,\n                                marginUsdt:     $marginBudget,\n                                riskMaxPct:     0.07,\n                                rMultiple:      2.0,\n                                meta:           ['ctx' => 'HC'],\n                                expireAfterSec: 120\n                            );\n                            $contextTrail[] = ['step' => 'order_submitted', 'type' => 'high_conviction'];\n                            $this->validationLogger->info('Order submitted [HIGH_CONVICTION]', [\n                                'symbol' => $symbol,\n                                'type' => 'high_conviction',\n                                'trail' => $contextTrail,\n                            ]);\n                        } catch (\\Throwable $e) {\n                            $insufficient = $this->isInsufficientBalanceError($e);\n                            $contextTrail[] = [\n                                'step' => 'order_failed',\n                                'type' => 'high_conviction',\n                                'error' => $e->getMessage(),\n                                'insufficient_balance' => $insufficient,\n                                'available_usdt' => $availableUsdt,\n                                'margin_usdt' => $marginBudget,\n                            ];\n\n                            $loggerContext = [\n                                'symbol' => $symbol,\n                                'error' => $e->getMessage(),\n                                'available_usdt' => $availableUsdt,\n                                'margin_usdt' => $marginBudget,\n                                'trail' => $contextTrail,\n                            ];\n\n                            if ($insufficient) {\n                                $this->validationLogger->warning('Insufficient balance, skipping order [HIGH_CONVICTION]', $loggerContext);\n                            } else {\n                                $this->validationLogger->error('Order submission failed [HIGH_CONVICTION]', $loggerContext);\n                            }\n                        }\n                    } else {\n                        $contextTrail[] = ['step' => 'opening_scalping'];\n                        $this->validationLogger->info('Opening position [SCALPING]', [\n                            'symbol'     => $symbol,\n                            'final_side' => $finalSide,\n                            'signal'     => $signalsPayload[$timeframe] ?? null,\n                            'trail'      => $contextTrail,\n                        ]);\n\n                        try {\n                            $this->positionOpener->openLimitAutoLevWithSr(\n                                symbol:         $symbol,\n                                finalSideUpper: $finalSide,\n                                marginUsdt:     70,\n                                riskMaxPct:     0.07,\n                                rMultiple:      3.0\n                            );\n                            $contextTrail[] = ['step' => 'order_submitted', 'type' => 'scalping'];\n                            $this->validationLogger->info('Order submitted [SCALPING]', [\n                                'symbol' => $symbol,\n                                'type' => 'scalping',\n                                'trail' => $contextTrail,\n                            ]);\n                        }\n                        catch (LeverageLowException $exception)\n                        {\n                            $this->validationLogger->error('Leverage balance [SCALPING]', [\n                                'symbol' => $symbol,\n                                'error' => $exception->getMessage(),\n                                'trail' => $contextTrail,\n                            ]);\n                        }\n                        catch (\\Throwable $e) {\n                            $contextTrail[] = ['step' => 'order_failed', 'type' => 'scalping', 'error' => $e->getMessage()];\n                            $this->validationLogger->error('Order submission failed [SCALPING]', [\n                                'symbol' => $symbol,\n                                'error' => $e->getMessage(),\n                                'trail' => $contextTrail,\n                            ]);\n                        }\n                    }\n                } else {\n                    $contextTrail[] = ['step' => 'final_side_none', 'signal' => $signalsPayload['final']['signal'] ?? 'NONE'];\n                    $this->validationLogger->info('Final decision not actionable', [\n                        'symbol' => $symbol,\n                        'timeframe' => $timeframe,\n                        'final_signal' => $signalsPayload['final']['signal'] ?? 'NONE',\n                        'trail' => $contextTrail,\n                    ]);\n                }\n\npipeline_lock:\n                if ($pipeline) {\n                    $contextTrail[] = ['step' => 'pipeline_locked'];\n                    $pipeline->setStatus(\\App\\Entity\\ContractPipeline::STATUS_OPENED_LOCKED);\n                    $this->em->flush();\n                    $this->validationLogger->info('Pipeline locked (OPENED_LOCKED)', [\n                        'pipeline_id' => $pipeline->getId(),\n                        'symbol'      => $symbol,\n                        'trail'       => $contextTrail,\n                    ]);\n                }\n            } elseif ($isValid) {\n                $contextTrail[] = ['step' => 'window_not_eligible'];\n                $this->validationLogger->info('Window not eligible for opening despite valid decision', [\n                    'symbol' => $symbol,\n                    'timeframe' => $timeframe,\n                    'final_signal' => $signalsPayload['final']['signal'] ?? 'NONE',\n                    'trail' => $contextTrail,\n                ]);\n            }\n        }\n\n        // 8) Nettoyage pipeline si demandé\n        if ($pipeline && $pipeline->isToDelete() && $pipeline->getId()) {\n            $pipelineId = $pipeline->getId();\n            $pipeline = $this->em->getRepository(\\App\\Entity\\ContractPipeline::class)->find($pipelineId);\n            if ($pipeline) {\n                $this->em->remove($pipeline);\n                $this->em->flush();\n                $this->logger->info('Pipeline deleted after decision', [\n                    'symbol' => $symbol,\n                    'timeframe' => $timeframe,\n                ]);\n            }\n        }\n\n        // Log final (pas de start/end désormais)\n        $this->logger->info('Klines persisted + evaluated', [\n            'symbol'       => $symbol,\n            'timeframe'    => $timeframe,\n            'step_minutes' => $stepMinutes,\n            'affected'     => $affected,\n        ]);\n\n        // Réponse\n        if (($signalsPayload[$timeframe]['signal'] ?? 'NONE') === 'NONE') {\n            return new JsonResponse([\n                'status'    => 'KO',\n                'symbol'    => $symbol,\n                'timeframe' => $timeframe,\n                'persisted' => $affected,\n                'window'    => ['limit' => $limit],\n                'signals'   => $signalsPayload,\n                'decision'  => $signalsPayload['final'] ?? null,\n            ]);\n        }\n\n        return new JsonResponse([\n            'status'    => 'ok',\n            'symbol'    => $symbol,\n            'timeframe' => $timeframe,\n            'persisted' => $affected,\n            'window'    => ['limit' => $limit],\n            'signals'   => $signalsPayload,\n            'decision'  => $signalsPayload['final'] ?? null,\n        ]);\n    }\n\n    private function isInsufficientBalanceError(\\Throwable $error): bool\n    {\n        $message = strtolower($error->getMessage());\n        if ($message === '') {\n            return false;\n        }\n\n        return str_contains($message, 'insufficient balance')\n            || str_contains($message, 'balance not sufficient')\n            || str_contains($message, 'balance not enough')\n            || str_contains($message, 'insufficient margin')\n            || str_contains($message, 'margin not enough');\n    }\n\n    private function jsonError(string $message, int $status): JsonResponse\n    {\n        return new JsonResponse(['status' => 'error', 'message' => $message], $status);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Controller/Bitmart/KlinesCallbackController.php b/symfony-app/src/Controller/Bitmart/KlinesCallbackController.php
--- a/symfony-app/src/Controller/Bitmart/KlinesCallbackController.php	(revision acfe8edc4f51e920bc6e35643a19748aa79bb144)
+++ b/symfony-app/src/Controller/Bitmart/KlinesCallbackController.php	(date 1759592597355)
@@ -305,7 +305,7 @@
                         'timeframe' => $timeframe,
                     ]);
 
-                    if ($isHigh && $levCap > 0) {
+                    if (false && $isHigh && $levCap > 0) { // un probleme avec leverage (not synchronised )
                         $availableUsdt = $this->bitmartAccount->getAvailableUSDT();
                         $marginBudget  = max(0.0, $availableUsdt * 0.5);
                         $contextTrail[] = [
@@ -388,9 +388,9 @@
                             $this->positionOpener->openLimitAutoLevWithSr(
                                 symbol:         $symbol,
                                 finalSideUpper: $finalSide,
-                                marginUsdt:     70,
+                                marginUsdt:     150,
                                 riskMaxPct:     0.07,
-                                rMultiple:      3.0
+                                rMultiple:      1.5
                             );
                             $contextTrail[] = ['step' => 'order_submitted', 'type' => 'scalping'];
                             $this->validationLogger->info('Order submitted [SCALPING]', [
Index: symfony-app/src/Service/Trading/PositionOpener.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\ndeclare(strict_types=1);\n\nnamespace App\\Service\\Trading;\n\nuse App\\Entity\\ContractPipeline;\nuse App\\Repository\\ContractPipelineRepository;\nuse App\\Repository\\ContractRepository;\nuse App\\Repository\\KlineRepository;\nuse App\\Service\\Config\\TradingParameters;\nuse App\\Service\\Exception\\Trade\\Position\\LeverageLowException;\nuse App\\Service\\Indicator\\AtrCalculator;\nuse App\\Util\\SrRiskHelper;\nuse InvalidArgumentException;\nuse Psr\\Log\\LoggerInterface;\nuse Throwable;\nuse RuntimeException;\nuse App\\Bitmart\\Http\\BitmartHttpClientPublic;\nuse App\\Service\\Bitmart\\Private\\OrdersService;\nuse App\\Service\\Bitmart\\Private\\PositionsService as BitmartPositionsService;\nuse App\\Service\\Bitmart\\Private\\TrailOrdersService;\n\nfinal class PositionOpener\n{\n\n    // --- Constantes spécifiques High Conviction ---\n    private const HC_DEFAULT_LEV_CAP     = 50;   // levier max autorisé par la stratégie HC\n    private const HC_MIN_LIQ_RATIO       = 3.0;  // liquidation ≥ 3x distance SL (si tu veux contrôler ici)\n    private const HC_DEFAULT_R_MULTIPLE  = 2.0;  // TP à 2R (cohérent YAML v1.2)\n    private const HC_DEFAULT_EXPIRE_SEC  = 120;  // annulation auto (2 minutes)\n\n    public function __construct(\n        private readonly AtrCalculator $atrCalculator,\n        private readonly TradingParameters $tradingParameters,\n        private readonly LoggerInterface $positionsLogger, // channel \"positions\"\n        private readonly ContractPipelineRepository $pipelineRepository,\n        private readonly ContractRepository $contractRepository,\n        private readonly KlineRepository $klineRepository,\n        private readonly OrdersService $ordersService,\n        private readonly BitmartPositionsService $bitmartPositions,\n        private readonly TrailOrdersService $trailOrders,\n        private readonly BitmartHttpClientPublic $bitmartPublic,\n    ) {}\n\n    /**\n     * Wrapper \"standard\" : utilise TradingParameters (pas d'override).\n     */\n    public function openMarketWithTpSl(\n        string $symbol,\n        string $finalSideUpper,   // 'LONG'|'SHORT'\n        string $timeframe,\n        array $tfSignal = [],\n        array $ohlc = [],\n        ?int $expireAfterSec = null\n    ): array {\n        return $this->doOpenWithOverrides(\n            symbol: $symbol,\n            finalSideUpper: $finalSideUpper,\n            timeframe: $timeframe,\n            tfSignal: $tfSignal,\n            ohlc: $ohlc,\n            expireAfterSec: $expireAfterSec\n        );\n    }\n\n    /**\n     * Variante demandée : budget = 50 USDT, risque absolu = 7 USDT (TP absolu = cfg).\n     */\n    public function openMarketWithTpSl50x7(\n        string $symbol,\n        string $finalSideUpper,   // 'LONG'|'SHORT'\n        string $timeframe,\n        array $tfSignal = [],\n        array $ohlc = [],\n    ): array {\n        return $this->doOpenWithOverrides(\n            symbol: $symbol,\n            finalSideUpper: $finalSideUpper,\n            timeframe: $timeframe,\n            tfSignal: $tfSignal,\n            ohlc: $ohlc,\n            budgetOverride: 50.0,\n            riskAbsOverride: 7.0\n        );\n    }\n\n    public function openLimitWithTpSlPct(\n        string $symbol,\n        string $finalSideUpper,    // 'LONG' | 'SHORT'\n        float $marginUsdt = 5.0,   // même défauts que ta commande\n        int   $leverage   = 1,\n        float $slPct      = 0.05,  // 5%\n        float $tpPct      = 0.10,  // 10%\n        string $timeframe = 'manual', // optionnel: pour logs\n        array $meta       = [],        // optionnel: pour tracer signal,etc.\n        ?int  $expireAfterSec = null\n    ): array {\n        return $this->doOpenLimitWithPct(\n            symbol: $symbol,\n            finalSideUpper: $finalSideUpper,\n            marginUsdt: $marginUsdt,\n            leverage: $leverage,\n            slPct: $slPct,\n            tpPct: $tpPct,\n            timeframe: $timeframe,\n            meta: $meta\n        );\n    }\n\n\n    /**\n     * Coeur factorisé : ouvre un market order avec TP/SL absolus (en USDT).\n     * Permet d’overrider budget / risque_abs / tp_abs au besoin.\n     */\n    private function doOpenWithOverrides(\n        string $symbol,\n        string $finalSideUpper,   // 'LONG'|'SHORT'\n        string $timeframe,\n        array $tfSignal = [],\n        array $ohlc = [],\n        ?float $budgetOverride = null,\n        ?float $riskAbsOverride = null,\n        ?float $tpAbsOverride = null,\n        ?int   $expireAfterSec = null\n    ): array {\n        $side = strtolower($finalSideUpper); // 'long'|'short'\n        $this->positionsLogger->info('===============================');\n        $this->positionsLogger->info('=== PositionOpener:start ===', [\n            'symbol'     => $symbol,\n            'side'       => $side,\n            'timeframe'  => $timeframe,\n            'signal'     => $tfSignal,\n            'ohlc_count' => \\count($ohlc),\n            'overrides'  => [\n                'budget'  => $budgetOverride,\n                'riskAbs' => $riskAbsOverride,\n                'tpAbs'   => $tpAbsOverride,\n            ],\n        ]);\n\n        $orderId = null;\n\n        try {\n            /* ------------------ 1) Config ------------------ */\n            $cfg = $this->tradingParameters->all();\n            $this->positionsLogger->info('Loaded trading config', $cfg);\n\n            $budgetCapUsdt = $budgetOverride ?? (float)($cfg['budget']['open_cap_usdt'] ?? 50.0);\n            $riskAbsUsdt   = $riskAbsOverride ?? (float)($cfg['risk']['abs_usdt'] ?? 3.0);\n            $tpAbsUsdt     = $tpAbsOverride   ?? (float)($cfg['tp']['abs_usdt'] ?? 5.0);\n\n            $riskPct       = (float)($cfg['risk']['pct'] ?? 0.02);\n            $atrLookback   = (int)  ($cfg['atr']['lookback'] ?? 14);\n            $atrMethod     = (string)($cfg['atr']['method'] ?? 'wilder');\n            $atrTimeframe  = (string)($cfg['atr']['timeframe'] ?? '15m');\n            $atrKStop      = (float)($cfg['atr']['k_stop'] ?? 1.5);\n            $tpRMultiple   = (float)($cfg['tp']['r_multiple'] ?? 2.0);\n            $openType      = (string)($cfg['margin']['open_type'] ?? 'isolated');\n\n            if (\\count($ohlc) === 0) {\n                $needed = max($atrLookback + 1, 120);\n                $ohlc = $this->klineRepository->findLastKlines(\n                    symbol: $symbol,\n                    timeframe: $atrTimeframe,\n                    limit: $needed\n                );\n                $this->positionsLogger->info('ATR OHLC source loaded', [\n                    'timeframe' => $atrTimeframe,\n                    'requested' => $needed,\n                    'actual'    => \\count($ohlc)\n                ]);\n            }\n\n            if (\\count($ohlc) <= $atrLookback) {\n                throw new InvalidArgumentException(\"OHLC insuffisant pour ATR (tf=$atrTimeframe, lookback=$atrLookback)\");\n            }\n\n            /* ------------------ 2) Contract details ------------------ */\n            $details = $this->getContractDetails($symbol);\n            $this->positionsLogger->info('Contract details loaded', $details);\n\n            $status = (string)($details['status'] ?? 'Trading');\n            if ($status !== 'Trading') {\n                throw new RuntimeException(\"Symbol status is '$status' (not Trading)\");\n            }\n\n            $tick     = (float)($details['price_precision'] ?? 0.0);\n            $qtyStep  = (float)($details['vol_precision']   ?? 0.0);\n            $ctSize   = (float)($details['contract_size']   ?? 0.0);\n            $minVol   = (int)  ($details['min_volume']      ?? 1);\n            $maxVol   = (int)  ($details['max_volume']      ?? PHP_INT_MAX);\n            $maxLev   = (int)  ($details['max_leverage']    ?? 50);\n            $marketCap = isset($details['market_max_volume']) && (int)$details['market_max_volume'] > 0\n                ? (int)$details['market_max_volume'] : null;\n\n            if ($tick <= 0 || $qtyStep <= 0 || $ctSize <= 0 || $minVol <= 0) {\n                throw new RuntimeException(\"Invalid contract details: tick=$tick qtyStep=$qtyStep ctSize=$ctSize minVol=$minVol\");\n            }\n\n            /* ------------------ 3) Mark price ------------------ */\n            $mark = $this->getMarkClose($symbol);\n            $this->positionsLogger->info('Mark price fetched', ['mark' => $mark]);\n\n            /* ------------------ 4) ATR & SL/TP (preview) ------------------ */\n            $atr       = $this->atrCalculator->compute($ohlc, $atrLookback, $atrMethod);\n            $stopDist  = $atrKStop * $atr;\n            $stopPct   = $stopDist / max(1e-9, $mark);\n            $slRawATR  = $this->atrCalculator->stopFromAtr($mark, $atr, $atrKStop, $side);\n            $tpRawATR  = $this->computeTpPrice($side, $mark, $stopDist, $tpRMultiple);\n\n            $this->positionsLogger->info('ATR preview SL/TP (will be overridden by absolute USDT after sizing)', [\n                'entry'     => $mark,\n                'atr'       => $atr,\n                'atr_tf'    => $atrTimeframe,\n                'k_stop'    => $atrKStop,\n                'stop_dist' => $stopDist,\n                'stop_pct'  => $stopPct,\n                'sl_raw_atr'=> $slRawATR,\n                'tp_raw_atr'=> $tpRawATR,\n            ]);\n\n            /* ------------------ 5) Leverage ------------------ */\n            // Plancher 2x conservé (adapter à 1/3 si besoin).\n            $notionalRisk = ($budgetCapUsdt * $riskPct) / max(1e-9, $stopPct);\n            $levFloor     = (int)\\ceil($notionalRisk / $budgetCapUsdt);\n            $levFromSizing= max(1, $levFloor);\n\n            $currentLev = $this->getCurrentLeverageSafe($symbol);\n            $targetLev = (int)($maxLev * 0.2);\n            $this->positionsLogger->info(\"Leverage calculation\", [\n                'lev_from_budget' => $levFromSizing,\n                'lev_floor_2x'    => $levFloor,\n                'max_lev_contract'=> $maxLev,\n                'current_lev'     => $currentLev,\n            ]);\n            if ($levFromSizing < $targetLev) {\n                $this->positionsLogger->info(\"Leverage calculation => no need to open leverage too low \");\n                throw LeverageLowException::trigger($symbol, $maxLev,  $levFromSizing);\n            }\n            $factor     = $currentLev > 0 ? $targetLev / $currentLev : $targetLev;\n\n            $this->positionsLogger->info('Leverage adjust', [\n                'current' => $currentLev,\n                'lev_from_sizing' => $levFromSizing,\n                'target'  => $targetLev,\n                'factor_vs_current' => $factor,\n            ]);\n\n            $this->bitmartPositions->setLeverage($symbol, $targetLev, $openType);\n            $this->positionsLogger->info('Leverage set', [\n                'symbol'   => $symbol,\n                'leverage' => $targetLev,\n                'openType' => $openType,\n            ]);\n\n            /* ------------------ 6) Contracts sizing ------------------ */\n            // (A) Contraint par budget\n            $notionalBudget   = $budgetCapUsdt * $targetLev;\n            $contractsBudget  = floor(($notionalBudget / ($mark * $ctSize)) / $qtyStep) * $qtyStep;\n\n            // (B) Contraint par risque absolu (distance ATR)\n            $contractsRisk    = floor(($riskAbsUsdt / ($stopDist * $ctSize)) / $qtyStep) * $qtyStep;\n\n            // (C) Final borné par min/max/marketCap\n            $contracts = (int)max(\n                $minVol,\n                min($contractsBudget, $contractsRisk, $maxVol, $marketCap ?? INF)\n            );\n\n            $this->positionsLogger->info('Contracts sizing', [\n                'contracts_budget' => $contractsBudget,\n                'contracts_risk'   => $contractsRisk,\n                'contracts_final'  => $contracts,\n                'budget_used_usdt' => $budgetCapUsdt,\n                'risk_abs_usdt'    => $riskAbsUsdt,\n            ]);\n\n            /* ------------------ 6bis) TP/SL ABSOLUS (USDT) ------------------ */\n            $qtyNotional = max(1e-9, $contracts * $ctSize);\n\n            if ($side === 'long') {\n                // long: PnL = qty*(price - entry)\n                $slRaw = $mark - ($riskAbsUsdt / $qtyNotional);\n                $tpRaw = $mark + ($tpAbsUsdt   / $qtyNotional);\n            } else {\n                // short: PnL = qty*(entry - price)\n                $slRaw = $mark + ($riskAbsUsdt / $qtyNotional);\n                $tpRaw = $mark - ($tpAbsUsdt   / $qtyNotional);\n            }\n\n            $slQ = $this->quantizeToStep($slRaw, $tick);\n            $tpQ = $this->quantizeToStep($tpRaw, $tick);\n\n            $this->positionsLogger->info('SL/TP absolute override (USDT)', [\n                'entry'         => $mark,\n                'qty_notional'  => $qtyNotional,\n                'tp_abs_usdt'   => $tpAbsUsdt,\n                'sl_abs_usdt'   => $riskAbsUsdt,\n                'sl_q'          => $slQ,\n                'tp_q'          => $tpQ,\n            ]);\n\n            /* ------------------ 7) Market order avec presets ------------------ */\n            $clientOrderId = 'SF_' . bin2hex(random_bytes(8));\n            $bodyOpen = [\n                'symbol'          => $symbol,\n                'client_order_id' => $clientOrderId,\n                'side'            => $this->mapSideOpen($side),\n                'mode'            => 1,\n                'type'            => 'market',\n                'open_type'       => $openType,\n                'size'            => $contracts,\n                'preset_take_profit_price_type' => -2, // mark/fair\n                'preset_stop_loss_price_type'   => -2, // mark/fair\n                'preset_take_profit_price'      => (string)$tpQ,\n                'preset_stop_loss_price'        => (string)$slQ,\n            ];\n            $this->positionsLogger->info('Submitting market order', $bodyOpen);\n\n            $submit = $this->ordersService->create($bodyOpen);\n            $this->positionsLogger->info('Market order response', $submit);\n\n            if (($submit['code'] ?? 0) !== 1000) {\n                throw new RuntimeException('submit-order error: ' . json_encode($submit));\n            }\n            $orderId = $submit['data']['order_id'] ?? null;\n            if ($expireAfterSec !== null) {\n                try {\n                    $this->scheduleCancelAllAfter($symbol, $expireAfterSec);\n                } catch (\\Throwable $e) {\n                    $this->positionsLogger->warning('scheduleCancelAllAfter failed', [\n                        'symbol' => $symbol,\n                        'timeout' => $expireAfterSec,\n                        'error' => $e->getMessage(),\n                    ]);\n                }\n            }\n\n            /* ------------------ 8) Résultat final ------------------ */\n            $result = [\n                'symbol'     => $symbol,\n                'side'       => $side,\n                'timeframe'  => $timeframe,\n                'order_id'   => $orderId,\n                'entry_mark' => $mark,\n                'sl'         => $slQ,\n                'tp'         => $tpQ,\n                'contracts'  => $contracts,\n                'atr'        => $atr,\n                'leverage'   => $targetLev,\n                'budget_used_usdt' => $budgetCapUsdt,\n                'risk_abs_usdt'    => $riskAbsUsdt,\n            ];\n            $this->positionsLogger->info('=== PositionOpener:end ===', $result);\n\n            return $result;\n\n        } catch (Throwable $e) {\n            $this->positionsLogger->error('PositionOpener failed', [\n                'error'  => $e->getMessage(),\n                'symbol' => $symbol,\n                'side'   => $side ?? null,\n            ]);\n            throw $e;\n        } finally {\n            $this->persistOrderId($symbol, $orderId, '[Market]');\n        }\n    }\n\n    private function doOpenLimitWithPct(\n        string $symbol,\n        string $finalSideUpper,\n        float $marginUsdt,\n        int   $leverage,\n        float $slPct,\n        float $tpPct,\n        string $timeframe,\n        array $meta = []\n    ): array {\n        $orderId = null;\n\n        try {\n            $side = strtolower($finalSideUpper);           // 'long'|'short'\n            $this->positionsLogger->info('=== PositionOpener:openLimit ===', compact(\n                'symbol','side','timeframe','marginUsdt','leverage','slPct','tpPct','meta'\n            ));\n\n            /* 1) Détails contrat */\n            $details = $this->getContractDetails($symbol);\n            $tick    = (float)($details['price_precision'] ?? 0.0);\n            $qtyStep = (float)($details['vol_precision']   ?? 0.0);\n            $ctSize  = (float)($details['contract_size']   ?? 0.0);\n            $minVol  = (int)  ($details['min_volume']      ?? 1);\n            $maxVol  = (int)  ($details['max_volume']      ?? PHP_INT_MAX);\n            $marketCap = isset($details['market_max_volume']) && (int)$details['market_max_volume'] > 0\n                ? (int)$details['market_max_volume'] : null;\n\n            if ($tick<=0 || $qtyStep<=0 || $ctSize<=0 || $minVol<=0) {\n                throw new \\RuntimeException(\"Invalid contract details\");\n            }\n\n            /* 2) Mark & limite arrondie au tick */\n            $mark  = $this->getMarkClose($symbol);\n            $limit = $this->quantizeToStep($mark, $tick);  // même logique que ta commande\n\n            /* 3) Levier = 1 (fail suave si déjà réglé) */\n            try { $this->bitmartPositions->setLeverage($symbol, $leverage, 'isolated'); } catch (\\Throwable) {}\n\n            /* 4) Sizing : notional = marge×levier → contrats */\n            $notional     = $marginUsdt * $leverage;\n            $contractsRaw = $notional / max(1e-12, $limit * $ctSize);\n            $contractsQ   = (int) $this->quantizeQty($contractsRaw, max(1e-9, $qtyStep));\n            $upper        = $marketCap !== null ? min($maxVol, $marketCap) : $maxVol;\n\n            if ($contractsQ < $minVol) {\n                throw new \\RuntimeException(sprintf(\n                    \"Budget insuffisant pour %s @levier=%dx : %.6f < minVol=%d (valeur 1 contrat≈%.4f USDT)\",\n                    $symbol, $leverage, $contractsRaw, $minVol, $ctSize * $limit\n                ));\n            }\n            $contracts = (int) max($minVol, min($contractsQ, $upper));\n\n            /* 5) SL/TP % (sur prix limite) puis quantize */\n            if ($side === 'long') {\n                $slRaw = $limit * (1.0 - $slPct);\n                $tpRaw = $limit * (1.0 + $tpPct);\n            } else {\n                $slRaw = $limit * (1.0 + $slPct);\n                $tpRaw = $limit * (1.0 - $tpPct);\n            }\n            $slQ = $this->quantizeToStep($slRaw, $tick);\n            $tpQ = $this->quantizeToStep($tpRaw, $tick);\n\n            /* 6) LIMIT avec presets TP/SL (price_type=2 mark) + stp_mode optionnel */\n            $clientOrderId = 'LIM_' . bin2hex(random_bytes(6));\n            $payload = [\n                'symbol'                        => $symbol,\n                'client_order_id'               => $clientOrderId,\n                'side'                          => $this->mapSideOpen($side), // 1/4 oneway\n                'mode'                          => 1,                          // GTC\n                'type'                          => 'limit',\n                'open_type'                     => 'isolated',\n                'leverage'                      => (string)$leverage,\n                'size'                          => $contracts,\n                'price'                         => (string)$limit,\n                'preset_take_profit_price_type' => 2, // 1=last, 2=fair/mark\n                'preset_stop_loss_price_type'   => 2,\n                'preset_take_profit_price'      => (string)$tpQ,\n                'preset_stop_loss_price'        => (string)$slQ,\n                'stp_mode'                      => 1, // cancel_maker (optionnel)\n            ];\n            $res = $this->ordersService->create($payload);\n            if (($res['code'] ?? 0) !== 1000) {\n                throw new \\RuntimeException('submit-order error: ' . json_encode($res, JSON_UNESCAPED_SLASHES));\n            }\n            $orderId = $res['data']['order_id'] ?? null;\n\n            /* 7) (Optionnel) Position TP/SL “plan_category=2” */\n            // Si tu veux la couche position en plus des presets:\n            try {\n                $reduceSide = $this->mapSideReduce($side); // 3: close long | 2: close short\n                $this->submitPositionTpSl(\n                    symbol: $symbol, orderType: 'take_profit', side: $reduceSide,\n                    triggerPrice: (string)$tpQ, priceType: 2, executivePrice: (string)$tpQ, category: 'limit'\n                );\n                $this->submitPositionTpSl(\n                    symbol: $symbol, orderType: 'stop_loss', side: $reduceSide,\n                    triggerPrice: (string)$slQ, priceType: 2, executivePrice: (string)$slQ, category: 'limit'\n                );\n            } catch (\\Throwable $e) {\n                $this->positionsLogger->warning('submitPositionTpSl failed; presets still active', ['error' => $e->getMessage()]);\n            }\n\n            $out = [\n                'symbol'     => $symbol,\n                'side'       => $side,\n                'timeframe'  => $timeframe,\n                'order_id'   => $orderId,\n                'limit'      => $limit,\n                'sl'         => $slQ,\n                'tp'         => $tpQ,\n                'contracts'  => $contracts,\n                'leverage'   => $leverage,\n                'notional'   => $notional,\n                'client_order_id' => $clientOrderId,\n            ];\n            $this->positionsLogger->info('=== PositionOpener:openLimit:end ===', $out);\n            return $out;\n        } finally {\n            $this->persistOrderId($symbol, $orderId, '[LimitPct]');\n        }\n    }\n\n    public function openLimitAutoLevWithTpSlPct(\n        string $symbol,\n        string $finalSideUpper,          // 'LONG' | 'SHORT'\n        float  $marginUsdt = 5.0,\n        float  $slRoi      = 0.05,       // 5% ROI (ex: 0.07 pour -7%)\n        float  $tpRoi      = 0.10,       // 10% ROI (ex: 0.12 pour +12%)\n        string $timeframe  = 'manual',\n        array  $meta       = [],\n        ?int   $expireAfterSec = null\n    ): array {\n        $orderId = null;\n\n        try {\n            $side = strtolower($finalSideUpper);\n\n            // 1) Détails contrat\n            $details = $this->getContractDetails($symbol);\n            $tick    = (float)($details['price_precision'] ?? 0.0);\n            $qtyStep = (float)($details['vol_precision']   ?? 0.0);\n            $ctSize  = (float)($details['contract_size']   ?? 0.0);\n            $minVol  = (int)  ($details['min_volume']      ?? 1);\n            $maxVol  = (int)  ($details['max_volume']      ?? PHP_INT_MAX);\n            $maxLev  = (int)  ($details['max_leverage']    ?? 50);\n            $marketCap = isset($details['market_max_volume']) && (int)$details['market_max_volume'] > 0\n                ? (int)$details['market_max_volume'] : null;\n\n            if ($tick<=0 || $qtyStep<=0 || $ctSize<=0 || $minVol<=0) {\n                throw new \\RuntimeException(\"Invalid contract details\");\n            }\n\n            // 2) Prix limite ~= mark arrondi au tick\n            $mark  = $this->getMarkClose($symbol);\n            $limit = $this->quantizeToStep($mark, $tick);\n\n            // 3) Config (risque absolu)\n            $cfg          = $this->tradingParameters->all();\n            $riskAbsUsdt  = (float)($cfg['risk']['abs_usdt'] ?? 3.0);\n\n// 4) Levier cible (ta règle actuelle) + contrainte minVol/budget\n            $leverageTarget = max(4, (int)floor($maxLev / 2)); // ou ta règle dynamique variation_pct\n            $leverage = min($maxLev, $leverageTarget);\n\n// 5) S'assure que minVol est réalisable dans le budget souhaité (marge<=marginUsdt)\n            $notionalForMinVol = $minVol * $limit * $ctSize;\n            $leverageNeededForMinVol = (int)ceil($notionalForMinVol / max(1e-12, $marginUsdt));\n            if ($leverageNeededForMinVol > $maxLev) {\n                throw new \\RuntimeException(sprintf(\n                    \"Budget insuffisant: minVol=%d nécessite levier≥%dx pour marge=%g USDT (maxLev=%dx).\",\n                    $minVol, $leverageNeededForMinVol, $marginUsdt, $maxLev\n                ));\n            }\n            $leverage = max($leverage, $leverageNeededForMinVol);\n\n// 6) Calcul budget dur (notional max autorisé par la marge visée)\n            $notionalMax = $marginUsdt * $leverage;\n\n// 7) Sizing par le risque avec le LEVIER RÉEL\n//    stopDist = %mouvement prix correspondant à slRoi/leverage\n            $slPct   = abs($slRoi) / max(1e-12, $leverage);\n            $stopDist = $limit * $slPct;\n            $contractsRiskF = $riskAbsUsdt / max(1e-12, $stopDist * $ctSize);\n            $contractsRiskQ = $this->quantizeQty($contractsRiskF, max(1e-9, $qtyStep));\n\n// 8) Sizing par BUDGET (cap dur) et bornes exchange\n            $contractsBud = $this->quantizeQty(\n                $notionalMax / max(1e-12, $limit * $ctSize),\n                max(1e-9, $qtyStep)\n            );\n            $upperCap = $marketCap !== null ? min($maxVol, $marketCap) : $maxVol;\n\n// 9) Candidat sans dépasser le budget (ni caps), mais ≥ minVol\n            $candidate = max($minVol, min($contractsRiskQ, $contractsBud, $upperCap));\n\n// Si le risque demande plus que le budget, tente d'augmenter le levier (jusqu'à maxLev)\n            if ($candidate < max($minVol, min($contractsRiskQ, $upperCap))) {\n                $contractsNeeded = max($minVol, min($contractsRiskQ, $upperCap));\n                $notionalNeeded  = $contractsNeeded * $limit * $ctSize;\n                $levNeeded       = (int)ceil($notionalNeeded / max(1e-12, $marginUsdt));\n                if ($levNeeded <= $maxLev) {\n                    $leverage = max($leverage, $levNeeded);\n                    $notionalMax = $marginUsdt * $leverage;\n                    $contractsBud = $this->quantizeQty(\n                        $notionalMax / max(1e-12, $limit * $ctSize),\n                        max(1e-9, $qtyStep)\n                    );\n                    $candidate = max($minVol, min($contractsRiskQ, $contractsBud, $upperCap));\n                } else {\n                    // On reste dans le budget: on acceptera une taille < risque idéal\n                    $candidate = max($minVol, min($contractsBud, $upperCap));\n                }\n            }\n\n            $contracts = (int)$candidate;\n\n// 10) Recalcule TP/SL avec le levier réel (déjà fait ci-dessus pour slPct)\n            $tpPct = abs($tpRoi) / max(1e-12, $leverage);\n            if ($side === 'long') {\n                $slRaw = $limit * (1.0 - $slPct);\n                $tpRaw = $limit * (1.0 + $tpPct);\n            } else {\n                $slRaw = $limit * (1.0 + $slPct);\n                $tpRaw = $limit * (1.0 - $tpPct);\n            }\n            $slQ = $this->quantizeToStep($slRaw, $tick);\n            $tpQ = $this->quantizeToStep($tpRaw, $tick);\n\n// 11) Estimations honnêtes pour retour et contrôle\n            $notionalReal = $contracts * $limit * $ctSize;\n            $marginEst    = $notionalReal / max(1e-12, $leverage);\n\n// 12) Met à jour le payload + setLeverage\n            $clientOrderId = 'LIM_' . bin2hex(random_bytes(6));\n            $payload = [\n                'symbol'                        => $symbol,\n                'client_order_id'               => $clientOrderId,\n                'side'                          => $this->mapSideOpen($side),\n                'mode'                          => 1,\n                'type'                          => 'limit',\n                'open_type'                     => 'isolated',\n                'leverage'                      => (string)$leverage,\n                'size'                          => $contracts,\n                'price'                         => (string)$limit,\n                'preset_take_profit_price_type' => 2,\n                'preset_stop_loss_price_type'   => 2,\n                'preset_take_profit_price'      => (string)$tpQ,\n                'preset_stop_loss_price'        => (string)$slQ,\n                'stp_mode'                      => 1,\n            ];\n            $this->bitmartPositions->setLeverage($symbol, $leverage, 'isolated');\n            $res = $this->ordersService->create($payload);\n            if (($res['code'] ?? 0) !== 1000) {\n                throw new \\RuntimeException('submit-order error: ' . json_encode($res, JSON_UNESCAPED_SLASHES));\n            }\n            $orderId = $res['data']['order_id'] ?? null;\n\n            if ($expireAfterSec !== null) {\n                try { $this->scheduleCancelAllAfter($symbol, $expireAfterSec); } catch (\\Throwable $e) {\n                    $this->positionsLogger->warning('scheduleCancelAllAfter failed', [\n                        'symbol' => $symbol, 'timeout' => $expireAfterSec, 'error' => $e->getMessage()\n                    ]);\n                }\n            }\n\n            return [\n                'symbol'     => $symbol,\n                'side'       => $side,\n                'timeframe'  => $timeframe,\n                'order_id'   => $orderId,\n                'limit'      => $limit,\n                'sl'         => $slQ,\n                'tp'         => $tpQ,\n                'contracts'  => $contracts,\n                'leverage'   => $leverage,\n                'notional'   => $notionalMax,\n                'client_order_id' => $clientOrderId,\n                'meta'       => $meta,\n            ];\n        } finally {\n            $this->persistOrderId($symbol, $orderId, '[AutoLev]');\n        }\n    }\n\n\n    /** Quantize une quantité au pas (arrondi vers le bas) */\n    private function quantizeQty(float $v, float $step): float {\n        $this->ensurePositive($step, 'qty_step');\n        return floor($v / $step) * $step;\n    }\n\n\n    // ================= Helpers métier =================\n\n    /** Mapping ouverture one-way: long|buy -> 1 ; short|sell -> 4 */\n    private function mapSideOpen(string $side): int\n    {\n        return match (strtolower($side)) {\n            'long','buy'  => 1,\n            'short','sell'=> 4,\n            default       => throw new InvalidArgumentException(\"side invalide: $side\"),\n        };\n    }\n\n    /** Mapping reduce-only: fermer long => sell reduce(3), fermer short => buy reduce(2) */\n    private function mapSideReduce(string $openedSide): int\n    {\n        return match (strtolower($openedSide)) {\n            'long','buy'  => 3, // sell reduce\n            'short','sell'=> 2, // buy reduce\n            default       => throw new InvalidArgumentException(\"openedSide invalide: $openedSide\"),\n        };\n    }\n\n    /** Quantise au step le plus proche (tick/step prix) */\n    private function quantizeToStep(float $v, float $step): float\n    {\n        $this->ensurePositive($step, 'price_tick');\n        return round($v / $step) * $step;\n    }\n\n    /** TP à R-multiple de la distance de stop */\n    private function computeTpPrice(string $side, float $entry, float $stopDist, float $r): float\n    {\n        $d = $r * $stopDist;\n        return \\in_array($side, ['long','buy'], true) ? $entry + $d : $entry - $d;\n    }\n\n    /** SL arithmétique (si besoin hors ATR helper) */\n    private function computeSlPrice(string $side, float $entry, float $stopDist): float\n    {\n        return \\in_array($side, ['long','buy'], true) ? $entry - $stopDist : $entry + $stopDist;\n    }\n\n    private function ensurePositive(float $value, string $name): void\n    {\n        if (!is_finite($value) || $value <= 0.0) {\n            $this->positionsLogger->error(\"$name doit être > 0 (reçu: $value)\");\n            throw new RuntimeException(\"$name doit être > 0 (reçu: $value)\");\n        }\n    }\n\n    // ================= HTTP BitMart =================\n\n    /** Détails contrat — récupère depuis la BDD (entité Contract) */\n    private function getContractDetails(string $symbol): array\n    {\n        $contract = $this->contractRepository->find($symbol);\n        if (!$contract) {\n            throw new RuntimeException(\"Contract $symbol not found in database\");\n        }\n\n        return [\n            'symbol' => $contract->getSymbol(),\n            'status' => $contract->getStatus(),\n            'price_precision' => $contract->getPricePrecision(),\n            'vol_precision' => $contract->getVolPrecision(),\n            'contract_size' => $contract->getContractSize(),\n            'min_volume' => $contract->getMinVolume(),\n            'max_volume' => $contract->getMaxVolume(),\n            'market_max_volume' => $contract->getMarketMaxVolume(),\n            'max_leverage' => $contract->getMaxLeverage(),\n            'min_leverage' => $contract->getMinLeverage(),\n        ];\n    }\n\n    /** MarkPrice K-line (step=1) → close_price de la dernière bougie */\n    private function getMarkClose(string $symbol): float\n    {\n        $now = time();\n        $rows = $this->bitmartPublic->getMarkPriceKline(\n            symbol: $symbol,\n            step: 1,\n            limit: 2,\n            startTime: $now - 120,\n            endTime: $now\n        );\n        if (!$rows || !is_array($rows)) {\n            throw new RuntimeException('markprice-kline: pas de données');\n        }\n        $last  = end($rows);\n        $close = (float)($last['close_price'] ?? 0.0);\n        if ($close <= 0.0) {\n            throw new RuntimeException('markprice-kline: close_price invalide');\n        }\n        return $close;\n    }\n\n    /** (optionnel) Cap du levier par bracket ; retourne null si échec silencieux */\n    private function getMaxLeverageFromBracketSafe(string $symbol, float $notional): ?int\n    {\n        try {\n            $brackets = $this->bitmartPublic->getLeverageBrackets($symbol);\n            $maxLev = null;\n            foreach ($brackets as $b) {\n                $cap = (float)($b['notional_cap'] ?? INF);\n                if ($notional <= $cap) {\n                    $maxLev = (int)($b['max_leverage'] ?? 0);\n                    break;\n                }\n            }\n            return $maxLev ?: null;\n        } catch (Throwable) {\n            return null;\n        }\n    }\n\n    /** Règle le levier côté exchange (SIGNED) */\n    private function setLeverage(string $symbol, int $leverage, string $openType = 'isolated'): void\n    {\n        $this->positionsLogger->info('submit-leverage payload', [\n            'symbol' => $symbol,\n            'leverage' => $leverage,\n            'open_type' => $openType,\n        ]);\n\n        $resp = $this->bitmartPositions->setLeverage($symbol, $leverage, $openType);\n        $this->positionsLogger->info('submit-leverage response', $resp);\n\n        if (($resp['code'] ?? 0) !== 1000) {\n            throw new RuntimeException('submit-leverage error: ' . json_encode($resp, JSON_UNESCAPED_SLASHES));\n        }\n    }\n\n    /** Valide et normalise un plan-order TP/SL avant envoi */\n    private function buildPlanPayload(\n        string $symbol,\n        int $sideReduce,            // 2 buy_close_short | 3 sell_close_long\n        string $type,               // 'stop_loss' | 'take_profit'\n        int $size,\n        float $triggerQ,\n        float $execQ,\n        int $priceType = 2,         // 2 = fair/mark\n        ?int $planCategory = 2,     // 2 = Position TP/SL\n        string $category = 'market' // 'market' | 'limit'\n    ): array {\n        if (!\\in_array($type, ['stop_loss','take_profit'], true)) {\n            throw new InvalidArgumentException(\"Invalid plan type: $type\");\n        }\n        if (!\\in_array($sideReduce, [2,3], true)) {\n            throw new InvalidArgumentException(\"Invalid reduce side: $sideReduce (need 2 or 3)\");\n        }\n        if ($size <= 0) {\n            throw new InvalidArgumentException(\"Invalid size: $size\");\n        }\n        if (!\\in_array($priceType, [1,2], true)) {\n            throw new InvalidArgumentException(\"Invalid price_type: $priceType\");\n        }\n        if (!\\in_array($category, ['market','limit'], true)) {\n            throw new InvalidArgumentException(\"Invalid category: $category\");\n        }\n\n        $payload = [\n            'symbol'          => $symbol,\n            'side'            => $sideReduce,\n            'type'            => $type,\n            'size'            => $size,\n            'trigger_price'   => (string)$triggerQ,\n            'executive_price' => (string)$execQ,\n            'price_type'      => $priceType,\n            'category'        => $category,\n            'client_order_id' => strtoupper(substr($type,0,2)) . '_' . bin2hex(random_bytes(6)),\n        ];\n        if ($planCategory !== null) {\n            $payload['plan_category'] = $planCategory; // 2 = Position TP/SL\n        }\n        return $payload;\n    }\n\n    /** Envoie un plan TP/SL avec fallback: market→limit→price_type1→sans plan_category */\n    private function submitPlanOrderWithFallback(array $payload): array\n    {\n        // essai #1 : tel quel\n        $this->positionsLogger->info('PlanOrder try#1 JSON', ['json' => json_encode($payload, JSON_UNESCAPED_SLASHES)]);\n        $res = $this->trailOrders->create($payload);\n        if (($res['code'] ?? 0) === 1000) return $res;\n\n        $code = (int)($res['code'] ?? 0);\n        $this->positionsLogger->error('PlanOrder try#1 failed', ['code' => $code, 'resp' => $res]);\n\n        // essai #2 : switch category -> 'limit'\n        $p2 = $payload; $p2['category'] = 'limit';\n        $this->positionsLogger->info('PlanOrder try#2 JSON', ['json' => json_encode($p2, JSON_UNESCAPED_SLASHES)]);\n        $res2 = $this->trailOrders->create($p2);\n        if (($res2['code'] ?? 0) === 1000) return $res2;\n\n        $code2 = (int)($res2['code'] ?? 0);\n        $this->positionsLogger->error('PlanOrder try#2 failed', ['code' => $code2, 'resp' => $res2]);\n\n        // essai #3 : switch price_type -> 1 (last_price)\n        $p3 = $p2; $p3['price_type'] = 1;\n        $this->positionsLogger->info('PlanOrder try#3 JSON', ['json' => json_encode($p3, JSON_UNESCAPED_SLASHES)]);\n        $res3 = $this->trailOrders->create($p3);\n        if (($res3['code'] ?? 0) === 1000) return $res3;\n\n        $code3 = (int)($res3['code'] ?? 0);\n        $this->positionsLogger->error('PlanOrder try#3 failed', ['code' => $code3, 'resp' => $res3]);\n\n        // essai #4 : enlever plan_category\n        $p4 = $p3; unset($p4['plan_category']);\n        $this->positionsLogger->info('PlanOrder try#4 JSON', ['json' => json_encode($p4, JSON_UNESCAPED_SLASHES)]);\n        $res4 = $this->trailOrders->create($p4);\n        if (($res4['code'] ?? 0) === 1000) return $res4;\n\n        $this->positionsLogger->error('PlanOrder all tries failed', [\n            'first' => $res, 'second' => $res2, 'third' => $res3, 'fourth' => $res4\n        ]);\n        throw new RuntimeException('submit-plan-order failed after 4 attempts: ' . json_encode($res4, JSON_UNESCAPED_SLASHES));\n    }\n\n    private function getCurrentLeverageSafe(string $symbol): int\n    {\n        try {\n            $resp = $this->bitmartPositions->list(['symbol' => $symbol]);\n            $data = $resp['data'] ?? null;\n\n            $leverage = null;\n            if (\\is_array($data)) {\n                if (isset($data['leverage'])) {\n                    $leverage = (int)$data['leverage'];\n                } elseif (isset($data[0]['leverage'])) {\n                    $leverage = (int)$data[0]['leverage'];\n                }\n            }\n\n            $lev = $leverage ?? 0;\n            return $lev > 0 ? $lev : 1;\n        } catch (Throwable $e) {\n            $this->positionsLogger->warning('getCurrentLeverageSafe failed, defaulting to 1', [\n                'symbol' => $symbol, 'error' => $e->getMessage()\n            ]);\n            return 1;\n        }\n    }\n\n    private function quantizeDown(float $v, float $step): float { return floor($v/$step)*$step; }\n    private function quantizeUp(float $v, float $step): float { return ceil($v/$step)*$step; }\n\n    /** Programme l'annulation de TOUS les ordres du symbole après N secondes.\n     *  timeout: secondes (min 5). Mettre 0 pour désactiver le timer.\n     */\n    public function scheduleCancelAllAfter(string $symbol, int $timeoutSeconds): array\n    {\n        if ($timeoutSeconds < 0) {\n            throw new \\InvalidArgumentException('timeoutSeconds doit être >= 0 (0 pour désactiver)');\n        }\n        if ($timeoutSeconds !== 0 && $timeoutSeconds < 5) {\n            throw new \\InvalidArgumentException('timeoutSeconds doit être >= 5 (ou 0 pour annuler le réglage)');\n        }\n\n        $this->positionsLogger->info('Submitting cancel-all-after', [\n            'symbol' => $symbol,\n            'timeout' => $timeoutSeconds,\n        ]);\n\n        $res = $this->trailOrders->cancelAllAfter($symbol, $timeoutSeconds);\n        $this->positionsLogger->info('cancel-all-after response', $res);\n\n        if (($res['code'] ?? 0) !== 1000) {\n            throw new \\RuntimeException('cancel-all-after error: ' . json_encode($res, JSON_UNESCAPED_SLASHES));\n        }\n        return $res;\n    }\n\n    /**\n     * Calcule les métriques ROI à partir de l'entrée, du TP, du SL et du risque max.\n     *\n     * ROI% = ( |Pe - Ptp| / Pe * 100 ) * ( RiskMax% / ( |Psl - Pe| / Pe * 100 ) )\n     *\n     * @param float  $entry          Prix d'entrée\n     * @param float  $tp             Take Profit\n     * @param float  $sl             Stop Loss\n     * @param float  $riskMaxPercent Risque max toléré sur la marge (ex: 0.07 pour 7%)\n     * @param string $sideUpper      'LONG' | 'SHORT'\n     *\n     * @return array{\n     *   tp_pct: float,     // % variation jusqu'au TP (prix)\n     *   sl_pct: float,     // % variation jusqu'au SL (prix)\n     *   lev_opt: float,    // levier optimal pour respecter RiskMax%\n     *   roi_pct: float,    // ROI attendu en % du capital engagé\n     *   side: string       // 'LONG' | 'SHORT'\n     * }\n     */\n    private function calcRoiMetrics(\n        float $entry,\n        float $tp,\n        float $sl,\n        float $riskMaxPercent,\n        string $sideUpper\n    ): array {\n        $side = strtolower($sideUpper);\n\n        if ($entry <= 0.0) {\n            throw new \\InvalidArgumentException(\"Entry price must be > 0.\");\n        }\n        if ($riskMaxPercent <= 0.0) {\n            throw new \\InvalidArgumentException(\"RiskMax% must be > 0 (e.g. 0.07 for 7%).\");\n        }\n\n        // Validation directionnelle simple (non bloquante : warnings possibles selon ta politique)\n        if ($side === 'long') {\n            if ($tp <= $entry) {\n                // logger un avertissement si tu veux\n            }\n            if ($sl >= $entry) {\n                // logger un avertissement si tu veux\n            }\n        } elseif ($side === 'short') {\n            if ($tp >= $entry) {\n                // logger un avertissement si tu veux\n            }\n            if ($sl <= $entry) {\n                // logger un avertissement si tu veux\n            }\n        } else {\n            throw new \\InvalidArgumentException(\"sideUpper must be 'LONG' or 'SHORT'.\");\n        }\n\n        // Variations en % (du PRIX), indépendantes du sens\n        $slPct = abs($sl - $entry) / $entry * 100.0;\n        $tpPct = abs($tp - $entry) / $entry * 100.0;\n\n        if ($slPct == 0.0) {\n            throw new \\InvalidArgumentException(\"Stop Loss identique à l'entrée : calcul impossible.\");\n        }\n\n        // Levier optimal pour ne pas dépasser le risque max (sur la marge)\n        // lev_opt = RiskMax% / stop%\n        $levOpt = ($riskMaxPercent * 100.0) / $slPct;\n\n        // ROI attendu (en % du capital engagé)\n        // roi% = tp% * lev_opt\n        $roiPct = $tpPct * $levOpt;\n\n        return [\n            'tp_pct'  => $tpPct,\n            'sl_pct'  => $slPct,\n            'lev_opt' => $levOpt,\n            'roi_pct' => $roiPct,\n            'side'    => strtoupper($sideUpper),\n        ];\n    }\n    public function openLimitAutoLevWithSr(\n        string $symbol,\n        string $finalSideUpper,        // 'LONG' | 'SHORT'\n        float  $marginUsdt = 5.0,\n        float  $riskMaxPct = 0.07,     // 7% risque max sur la marge\n        float  $rMultiple  = 2.0,      // Take Profit à 2R par défaut\n        array  $meta = [],\n        ?int   $expireAfterSec = 120   // annule les ordres après 2 minutes\n    ): array {\n        $orderId = null;\n\n        try {\n            $side = strtoupper($finalSideUpper);\n\n        $this->positionsLogger->info('[SR] Étape 1: Récupération des détails du contrat', [\n            'symbol' => $symbol\n        ]);\n        $details = $this->getContractDetails($symbol);\n        $tick    = (float)($details['price_precision'] ?? 0.0);\n        $qtyStep = (float)($details['vol_precision']   ?? 0.0);\n        $ctSize  = (float)($details['contract_size']   ?? 0.0);\n        $maxLev  = (int)  ($details['max_leverage']    ?? 50);\n\n        if ($tick <= 0 || $qtyStep <= 0 || $ctSize <= 0) {\n            $this->positionsLogger->error('[SR] Détails contrat invalides', compact('tick', 'qtyStep', 'ctSize'));\n            throw new \\RuntimeException(\"Invalid contract details for $symbol\");\n        }\n\n        $this->positionsLogger->info('[SR] Étape 2: Récupération du prix mark', [\n            'symbol' => $symbol\n        ]);\n        $mark  = $this->getMarkClose($symbol);\n        $limit = $this->quantizeToStep($mark, $tick);\n        $this->positionsLogger->info('[SR] Prix d\\'entrée arrondi', [\n            'mark' => $mark,\n            'limit' => $limit\n        ]);\n\n        $cfg = $this->tradingParameters->all();\n        $atrLookback  = (int)($cfg['atr']['lookback'] ?? 14);\n        $atrMethod    = (string)($cfg['atr']['method'] ?? 'wilder');\n        $atrTimeframe = (string)($cfg['atr']['timeframe'] ?? '5m');\n        $atrSeries = $this->klineRepository->findLastKlines(\n            symbol: $symbol,\n            timeframe: $atrTimeframe,\n            limit: max($atrLookback + 1, 200)\n        );\n        if (count($atrSeries) <= $atrLookback) {\n            $this->positionsLogger->error('[SR] Pas assez de bougies pour l\\'ATR', [\n                'timeframe' => $atrTimeframe,\n                'count'     => count($atrSeries),\n                'lookback'  => $atrLookback\n            ]);\n            throw new \\RuntimeException(\"Not enough OHLC for ATR ($symbol tf=$atrTimeframe)\");\n        }\n        $atrValue = $this->atrCalculator->compute($atrSeries, $atrLookback, $atrMethod);\n        $this->positionsLogger->info('[SR] ATR source', [\n            'timeframe' => $atrTimeframe,\n            'lookback'  => $atrLookback,\n            'atr'       => $atrValue\n        ]);\n\n        $this->positionsLogger->info('[SR] Étape 3: Chargement des klines pour S/R', [\n            'symbol' => $symbol\n        ]);\n        $klines15m = $this->klineRepository->findLastKlines(\n            symbol: $symbol,\n            timeframe: '15m',\n            limit: 200\n        );\n\n        if (count($klines15m) < 50) {\n            $this->positionsLogger->error('[SR] Pas assez de klines pour la détection S/R', [\n                'count' => count($klines15m)\n            ]);\n            throw new \\RuntimeException(\"Not enough klines for SR detection ($symbol)\");\n        }\n        // Log de la date du dernier kline et de la date courante alignée\n        $lastKline = end($klines15m);\n        $lastOpen  = $lastKline['open_time'] ?? null; // adapte si ta BDD stocke différemment\n        if ($lastOpen !== null) {\n            $lastOpenDt = (new \\DateTimeImmutable())->setTimestamp((int)$lastOpen)->setTimezone(new \\DateTimeZone('UTC'));\n            $alignedDt  = \\App\\Util\\TimeframeHelper::getAlignedOpen('15m');\n\n            $this->positionsLogger->info('[SR] Comparaison temps klines', [\n                'last_kline_open' => $lastOpenDt->format('Y-m-d H:i:s T'),\n                'aligned_now'     => $alignedDt->format('Y-m-d H:i:s T'),\n                'now_utc'         => (new \\DateTimeImmutable('now', new \\DateTimeZone('UTC')))->format('Y-m-d H:i:s T'),\n            ]);\n        }\n\n\n        $this->positionsLogger->info('[SR] Étape 4: Détection S/R');\n        $sr = SrRiskHelper::findSupportResistance($klines15m);\n        $sr['atr'] = $atrValue;\n\n        $this->positionsLogger->info('[SR] Étape 5: Calcul du Stop Loss via S/R + ATR', [\n            'side' => $side,\n            'limit' => $limit,\n            'supports' => $sr['supports'],\n            'resistances' => $sr['resistances'],\n            'atr' => $sr['atr'],\n            'atr_tf' => $atrTimeframe\n        ]);\n        $slRaw = SrRiskHelper::chooseSlFromSr($side, $limit, $sr['supports'], $sr['resistances'], $sr['atr']);\n        $slQ   = $this->quantizeToStep($slRaw, $tick);\n\n        $this->positionsLogger->info('[SR] Étape 6: Calcul du levier optimal', [\n            'limit' => $limit,\n            'slQ' => $slQ,\n            'riskMaxPct' => $riskMaxPct,\n            'maxLev' => $maxLev\n        ]);\n        $levOptFloat = SrRiskHelper::leverageFromRisk($limit, $slQ, $riskMaxPct, $maxLev);\n        $levFinal    = max(1, min($maxLev, (int)ceil($levOptFloat)));\n\n\n        $this->positionsLogger->info('[SR] Étape 7: Calcul du Take Profit (R-multiple)', [\n            'rMultiple' => $rMultiple\n        ]);\n        $stopPct = abs($slQ - $limit) / $limit;\n        $tpTarget = $stopPct * $rMultiple;\n        $tpRaw = ($side === 'LONG')\n            ? $limit * (1.0 + $tpTarget)\n            : $limit * (1.0 - $tpTarget);\n        $tpQ = $this->quantizeToStep($tpRaw, $tick);\n\n        $this->positionsLogger->info('[SR] Étape 8: Sizing de la position', [\n            'marginUsdt' => $marginUsdt,\n            'levOpt' => $levFinal,\n            'limit' => $limit,\n            'ctSize' => $ctSize,\n            'qtyStep' => $qtyStep\n        ]);\n        $notionalMax = $marginUsdt * $levFinal;\n        $contractsBud = $this->quantizeQty(\n            $notionalMax / max(1e-12, $limit * $ctSize),\n            max(1e-9, $qtyStep)\n        );\n        $contracts = (int)max(1, $contractsBud);\n\n        $this->positionsLogger->info('[SR] Étape 9: Fixe le levier', [\n            'levOpt' => ceil($levFinal)\n        ]);\n        $this->bitmartPositions->setLeverage($symbol, $levFinal, 'isolated');\n        $this->waitLeverageSynchronized($symbol, $levFinal, 'isolated');\n\n        $clientOrderId = 'SR_' . bin2hex(random_bytes(6));\n        $payload = [\n            'symbol'                        => $symbol,\n            'client_order_id'               => $clientOrderId,\n            'side'                          => $this->mapSideOpen(strtolower($side)),\n            'mode'                          => 1,\n            'type'                          => 'limit',\n            'open_type'                     => 'isolated',\n            'leverage'                      => (string)$levFinal,\n            'size'                          => $contracts,\n            'price'                         => (string)$limit,\n            'preset_take_profit_price_type' => 2,\n            'preset_stop_loss_price_type'   => 2,\n            'preset_take_profit_price'      => (string)$tpQ,\n            'preset_stop_loss_price'        => (string)$slQ,\n            'stp_mode'                      => 1,\n        ];\n\n        $this->positionsLogger->info('[SR] Étape 10: Soumission de l\\'ordre', $payload);\n        $res = $this->ordersService->create($payload);\n        // Mise à jour du pipeline\n        try {\n            $this->pipelineRepository->updateStatusBySymbol(\n                symbol: $symbol,\n                status: ContractPipeline::STATUS_ORDER_OPENED\n            );\n            $this->positionsLogger->info('[SR] Pipeline mis à jour -> STATUS_ORDER_OPENED', [\n                'symbol' => $symbol,\n                'order_id' => $res['data']['order_id'] ?? null,\n                'status' => ContractPipeline::STATUS_ORDER_OPENED\n            ]);\n        } catch (\\Throwable $e) {\n            $this->positionsLogger->error('[SR] Erreur lors de la mise à jour du pipeline', [\n                'symbol' => $symbol,\n                'error' => $e->getMessage()\n            ]);\n        }\n\n        $this->positionsLogger->info('[SR] Réponse de l\\'API BitMart', $res);\n        if (($res['code'] ?? 0) !== 1000) {\n            $this->positionsLogger->error('[SR] Erreur lors de la soumission de l\\'ordre', [\n                'response' => $res\n            ]);\n            throw new \\RuntimeException('submit-order error: ' . json_encode($res, JSON_UNESCAPED_SLASHES));\n        }\n        $orderId = $res['data']['order_id'] ?? null;\n\n        if ($expireAfterSec !== null) {\n            $this->positionsLogger->info('[SR] Étape 11: Programmation de l\\'expiration auto', [\n                'expireAfterSec' => $expireAfterSec\n            ]);\n            try {\n                $this->trailOrders->cancelAllAfter($symbol, $expireAfterSec);\n            } catch (\\Throwable $e) {\n                $this->positionsLogger->warning('scheduleCancelAllAfter failed', [\n                    'symbol' => $symbol,\n                    'timeout' => $expireAfterSec,\n                    'error' => $e->getMessage()\n                ]);\n            }\n        }\n\n        $this->positionsLogger->info('[SR] Étape 12: Retour final', [\n            'symbol'     => $symbol,\n            'side'       => $side,\n            'order_id'   => $orderId,\n            'client_order_id' => $clientOrderId,\n            'limit'      => $limit,\n            'sl'         => $slQ,\n            'tp'         => $tpQ,\n            'contracts'  => $contracts,\n            'leverage'   => $levFinal,\n            'metrics'    => $sr,\n            'meta'       => $meta,\n        ]);\n\n        return [\n            'symbol'     => $symbol,\n            'side'       => $side,\n            'order_id'   => $orderId,\n            'client_order_id' => $clientOrderId,\n            'limit'      => $limit,\n            'sl'         => $slQ,\n            'tp'         => $tpQ,\n            'contracts'  => $contracts,\n            'leverage'   => $levFinal,\n            'metrics'    => $sr,\n            'meta'       => $meta,\n        ];\n        } finally {\n            $this->persistOrderId($symbol, $orderId, '[SR]');\n        }\n    }\n\n\n    /**\n     * Variante HIGH CONVICTION :\n     * - Même logique S/R + ATR que openLimitAutoLevWithSr()\n     * - Levier borné par $leverageCap (sans augmenter le risk %)\n     * - Garde le sizing budget→notional, puis quantize au pas d’échange\n     */\n    public function openLimitHighConvWithSr(\n        string $symbol,\n        string $finalSideUpper,           // 'LONG' | 'SHORT'\n        int    $leverageCap    = self::HC_DEFAULT_LEV_CAP,  // CAP HC (e.g. 50)\n        float  $marginUsdt     = 60.0,                      // ton budget d’ouverture\n        float  $riskMaxPct     = 0.07,                      // 7% risque max sur la marge (identique à SR)\n        float  $rMultiple      = self::HC_DEFAULT_R_MULTIPLE,\n        array  $meta           = [],\n        ?int   $expireAfterSec = self::HC_DEFAULT_EXPIRE_SEC\n    ): array {\n        $orderId = null;\n\n        try {\n            $side = strtoupper($finalSideUpper);\n\n        // 1) Détails contrat\n        $this->positionsLogger->info('[HC] Étape 1: Détails du contrat', ['symbol' => $symbol]);\n        $details = $this->getContractDetails($symbol);\n        $tick    = (float)($details['price_precision'] ?? 0.0);\n        $qtyStep = (float)($details['vol_precision']   ?? 0.0);\n        $ctSize  = (float)($details['contract_size']   ?? 0.0);\n        $maxLev  = (int)  ($details['max_leverage']    ?? 50);\n\n        if ($tick <= 0 || $qtyStep <= 0 || $ctSize <= 0) {\n            $this->positionsLogger->error('[HC] Détails contrat invalides', compact('tick','qtyStep','ctSize'));\n            throw new \\RuntimeException(\"Invalid contract details for $symbol\");\n        }\n\n        // 2) Prix (mark) & entrée\n        $this->positionsLogger->info('[HC] Étape 2: Mark price', ['symbol' => $symbol]);\n        $mark  = $this->getMarkClose($symbol);\n        $limit = $this->quantizeToStep($mark, $tick);\n        $this->positionsLogger->info('[HC] Prix d\\'entrée arrondi', ['mark' => $mark, 'limit' => $limit]);\n\n        $cfg = $this->tradingParameters->all();\n        $atrLookback  = (int)($cfg['atr']['lookback'] ?? 14);\n        $atrMethod    = (string)($cfg['atr']['method'] ?? 'wilder');\n        $atrTimeframe = (string)($cfg['atr']['timeframe'] ?? '5m');\n        $atrSeries = $this->klineRepository->findLastKlines(\n            symbol: $symbol,\n            timeframe: $atrTimeframe,\n            limit: max($atrLookback + 1, 200)\n        );\n        if (\\count($atrSeries) <= $atrLookback) {\n            $this->positionsLogger->error('[HC] Pas assez de bougies pour l\\'ATR', [\n                'timeframe' => $atrTimeframe,\n                'count'     => \\count($atrSeries),\n                'lookback'  => $atrLookback\n            ]);\n            throw new \\RuntimeException(\"Not enough OHLC for ATR ($symbol tf=$atrTimeframe)\");\n        }\n        $atrValue = $this->atrCalculator->compute($atrSeries, $atrLookback, $atrMethod);\n        $this->positionsLogger->info('[HC] ATR source', [\n            'timeframe' => $atrTimeframe,\n            'lookback'  => $atrLookback,\n            'atr'       => $atrValue\n        ]);\n\n        // 3) Klines pour S/R 15m\n        $this->positionsLogger->info('[HC] Étape 3: Chargement des klines (S/R)', ['symbol' => $symbol]);\n        $klines15m = $this->klineRepository->findLastKlines(symbol: $symbol, timeframe: '15m', limit: 200);\n        if (\\count($klines15m) < 50) {\n            $this->positionsLogger->error('[HC] Pas assez de klines pour S/R', ['count' => \\count($klines15m)]);\n            throw new \\RuntimeException(\"Not enough klines for SR detection ($symbol)\");\n        }\n\n        // 4) Détection S/R & SL basé S/R + ATR\n        $this->positionsLogger->info('[HC] Étape 4: Détection S/R');\n        $sr = \\App\\Util\\SrRiskHelper::findSupportResistance($klines15m);\n        $sr['atr'] = $atrValue;\n\n        $this->positionsLogger->info('[HC] Étape 5: Calcul SL via S/R + ATR', [\n            'side' => $side, 'limit' => $limit,\n            'supports' => $sr['supports'], 'resistances' => $sr['resistances'], 'atr' => $sr['atr'],\n            'atr_tf' => $atrTimeframe\n        ]);\n        $slRaw = \\App\\Util\\SrRiskHelper::chooseSlFromSr($side, $limit, $sr['supports'], $sr['resistances'], $sr['atr']);\n        $slQ   = $this->quantizeToStep($slRaw, $tick);\n\n        // 5) Levier optimal basé risque ⇒ borné par CAP HC et par maxLev exchange\n        $this->positionsLogger->info('[HC] Étape 6: Calcul du levier optimal (cap HC)', [\n            'riskMaxPct' => $riskMaxPct, 'maxLev' => $maxLev, 'capHC' => $leverageCap\n        ]);\n        $levOptRaw = \\App\\Util\\SrRiskHelper::leverageFromRisk($limit, $slQ, $riskMaxPct, $maxLev);\n        $levOpt    = min($levOptRaw, max(1, $leverageCap)); // bornage par CAP HC\n        if ($levOpt <= 0.0) {\n            throw new \\RuntimeException(\"[HC] leverageFromRisk returned non-positive leverage.\");\n        }\n\n        // 6) TP à R-multiple de la distance de stop\n        $this->positionsLogger->info('[HC] Étape 7: Calcul TP (R-multiple)', ['rMultiple' => $rMultiple]);\n        $stopPct  = abs($slQ - $limit) / max(1e-12, $limit);\n        $tpTarget = $stopPct * $rMultiple;\n        $tpRaw    = ($side === 'LONG') ? $limit * (1.0 + $tpTarget) : $limit * (1.0 - $tpTarget);\n        $tpQ      = $this->quantizeToStep($tpRaw, $tick);\n\n        // 7) Sizing par budget (marge × levier) → contrats\n        $this->positionsLogger->info('[HC] Étape 8: Sizing (budget & cap)', [\n            'marginUsdt' => $marginUsdt, 'levOptRaw' => $levOptRaw, 'levOptCapped' => $levOpt\n        ]);\n        $notionalMax = $marginUsdt * $levOpt;\n        $contractsBud = $this->quantizeQty(\n            $notionalMax / max(1e-12, $limit * $ctSize),\n            max(1e-9, $qtyStep)\n        );\n        $contracts = (int)max(1, $contractsBud);\n\n        // 8) (Optionnel) Garde liquidation locale (≥ 3× distance SL)\n        try {\n            $liqRatio = $this->estimateLiquidationDistanceRatio(\n                entry: $limit,\n                sl: $slQ,\n                sideUpper: $side,\n                leverage: (float)$levOpt,\n                symbol: $symbol\n            );\n            if ($liqRatio < self::HC_MIN_LIQ_RATIO) {\n                $this->positionsLogger->error('[HC] Liquidation guard KO', ['liq_ratio' => $liqRatio]);\n                throw new \\RuntimeException(\"[HC] liquidation ratio {$liqRatio} < \" . self::HC_MIN_LIQ_RATIO);\n            }\n        } catch (\\Throwable $e) {\n            // Si tu préfères soft-fail, remplace par un warning :\n            // $this->positionsLogger->warning('[HC] Liquidation guard check failed', ['error' => $e->getMessage()]);\n            throw $e;\n        }\n\n        // 9) Fixe le levier (côté exchange)\n        $this->positionsLogger->info('[HC] Étape 9: Fixe levier (exchange)', ['lev' => (int)\\ceil($levOpt)]);\n        $this->bitmartPositions->setLeverage($symbol, (int)\\ceil($levOpt), 'isolated');\n\n        // 10) Soumission LIMIT + presets TP/SL\n        $clientOrderId = 'HC_' . bin2hex(random_bytes(6));\n        $payload = [\n            'symbol'                        => $symbol,\n            'client_order_id'               => $clientOrderId,\n            'side'                          => $this->mapSideOpen(strtolower($side)),\n            'mode'                          => 1,\n            'type'                          => 'limit',\n            'open_type'                     => 'isolated',\n            'leverage'                      => (string)$levOpt,\n            'size'                          => $contracts,\n            'price'                         => (string)$limit,\n            'preset_take_profit_price_type' => 2, // mark/fair\n            'preset_stop_loss_price_type'   => 2,\n            'preset_take_profit_price'      => (string)$tpQ,\n            'preset_stop_loss_price'        => (string)$slQ,\n            'stp_mode'                      => 1,\n        ];\n\n        $this->positionsLogger->info('[HC] Étape 10: Soumission ordre', $payload);\n        $res = $this->ordersService->create($payload);\n        if (($res['code'] ?? 0) !== 1000) {\n            $this->positionsLogger->error('[HC] submit-order error', ['response' => $res]);\n            throw new RuntimeException('submit-order error: ' . json_encode($res, JSON_UNESCAPED_SLASHES));\n        }\n        $orderId = $res['data']['order_id'] ?? null;\n\n        // 11) Expiration auto (facultatif)\n        if ($expireAfterSec !== null) {\n            $this->positionsLogger->info('[HC] Étape 11: Expiration auto', ['expireAfterSec' => $expireAfterSec]);\n            try { $this->scheduleCancelAllAfter($symbol, $expireAfterSec); }\n            catch (\\Throwable $e) {\n                $this->positionsLogger->warning('[HC] scheduleCancelAllAfter failed', [\n                    'symbol' => $symbol, 'timeout' => $expireAfterSec, 'error' => $e->getMessage()\n                ]);\n            }\n        }\n\n        // 12) Mise à jour du pipeline (optionnel)\n        try {\n            $this->pipelineRepository->updateStatusBySymbol(\n                symbol: $symbol,\n                status: ContractPipeline::STATUS_ORDER_OPENED\n            );\n            $this->positionsLogger->info('[HC] Pipeline -> STATUS_ORDER_OPENED', [\n                'symbol' => $symbol, 'order_id' => $orderId\n            ]);\n        } catch (\\Throwable $e) {\n            $this->positionsLogger->error('[HC] Pipeline update failed', [\n                'symbol' => $symbol, 'error' => $e->getMessage()\n            ]);\n        }\n\n        $out = [\n            'symbol'     => $symbol,\n            'side'       => $side,\n            'order_id'   => $orderId,\n            'client_order_id' => $clientOrderId,\n            'limit'      => $limit,\n            'sl'         => $slQ,\n            'tp'         => $tpQ,\n            'contracts'  => $contracts,\n            'leverage'   => $levOpt,\n            'metrics'    => $sr,\n            'meta'       => array_merge($meta, [\n                'high_conviction' => true,\n                'leverage_cap'    => $leverageCap,\n            ]),\n        ];\n\n        $this->positionsLogger->info('[HC] Retour final', $out);\n        return $out;\n        } finally {\n            $this->persistOrderId($symbol, $orderId, '[HC]');\n        }\n    }\n\n    private function persistOrderId(string $symbol, string|int|null $orderId, string $context): void\n    {\n        if ($orderId === null) {\n            return;\n        }\n\n        $orderIdAsString = trim((string) $orderId);\n        if ($orderIdAsString === '') {\n            return;\n        }\n\n        try {\n            $this->pipelineRepository->updateOrderIdBySymbol($symbol, $orderIdAsString);\n            $this->positionsLogger->info(\"$context OrderId persisted in ContractPipeline\", [\n                'symbol' => $symbol,\n                'order_id' => $orderIdAsString,\n            ]);\n        } catch (Throwable $error) {\n            $this->positionsLogger->warning(\"$context Failed to persist orderId in ContractPipeline\", [\n                'symbol' => $symbol,\n                'order_id' => $orderIdAsString,\n                'error' => $error->getMessage(),\n            ]);\n        }\n    }\n\n    /**\n     * Estimation simple du ratio (distance_liquidation / distance_stop).\n     * Implémente la vraie formule de ton exchange si tu veux être exact.\n     */\n    private function estimateLiquidationDistanceRatio(\n        float $entry,\n        float $sl,\n        string $sideUpper,\n        float $leverage,\n        string $symbol\n    ): float {\n        // Approche conservative : liq ≈ entry * (1 ± 1/leverage) (simplifiée)\n        $side = strtoupper($sideUpper);\n        $liq  = ($side === 'LONG')\n            ? $entry * (1.0 - (1.0 / max(1e-12, $leverage)))\n            : $entry * (1.0 + (1.0 / max(1e-12, $leverage)));\n\n        $distStop = abs($entry - $sl);\n        $distLiq  = abs($entry - $liq);\n        if ($distStop <= 0.0) {\n            return INF;\n        }\n        return $distLiq / $distStop;\n    }\n\n\n    private function waitLeverageSynchronized(string $symbol, int $expected, string $openType = 'isolated', int $tries = 3, int $sleepMs = 150): void {\n        for ($i = 0; $i < $tries; $i++) {\n            try {\n                $resp = $this->bitmartPositions->list(['symbol' => $symbol]);\n                $data = $resp['data'] ?? [];\n                $lev = (int)($data['leverage'] ?? ($data[0]['leverage'] ?? 0));\n                if ($lev === $expected) return;\n            } catch (\\Throwable $e) {\n                // ignore et retry\n            }\n            usleep($sleepMs * 1000);\n        }\n        // En cas d’incertitude, on retente submit-leverage puis on continue\n        $this->setLeverage($symbol, $expected, $openType);\n    }\n\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Service/Trading/PositionOpener.php b/symfony-app/src/Service/Trading/PositionOpener.php
--- a/symfony-app/src/Service/Trading/PositionOpener.php	(revision acfe8edc4f51e920bc6e35643a19748aa79bb144)
+++ b/symfony-app/src/Service/Trading/PositionOpener.php	(date 1759599366560)
@@ -4,13 +4,18 @@
 namespace App\Service\Trading;
 
 use App\Entity\ContractPipeline;
+use App\Enum\OrderType;
+use App\Enum\Side;
 use App\Repository\ContractPipelineRepository;
 use App\Repository\ContractRepository;
 use App\Repository\KlineRepository;
 use App\Service\Config\TradingParameters;
 use App\Service\Exception\Trade\Position\LeverageLowException;
+use App\Service\Exchange\Bitmart\Dto\SubmitOrderRequestDto;
 use App\Service\Indicator\AtrCalculator;
+use App\Service\Indicator\SupportResistanceService;
 use App\Util\SrRiskHelper;
+use Doctrine\ORM\EntityManagerInterface;
 use InvalidArgumentException;
 use Psr\Log\LoggerInterface;
 use Throwable;
@@ -19,6 +24,8 @@
 use App\Service\Bitmart\Private\OrdersService;
 use App\Service\Bitmart\Private\PositionsService as BitmartPositionsService;
 use App\Service\Bitmart\Private\TrailOrdersService;
+use App\Service\Exchange\Bitmart\Dto\SubmitOrderResponseDto;
+use App\Enum\OrderOpenType;
 
 final class PositionOpener
 {
@@ -40,6 +47,8 @@
         private readonly BitmartPositionsService $bitmartPositions,
         private readonly TrailOrdersService $trailOrders,
         private readonly BitmartHttpClientPublic $bitmartPublic,
+        private readonly SupportResistanceService $srService,
+        private EntityManagerInterface $entityManager
     ) {}
 
     /**
@@ -226,7 +235,14 @@
             $levFromSizing= max(1, $levFloor);
 
             $currentLev = $this->getCurrentLeverageSafe($symbol);
-            $targetLev = (int)($maxLev * 0.2);
+            if (in_array($symbol, ['BTCUSDT', 'ETHUSDT', 'BNBUSDT'], true)) {
+                // BTC/ETH: on plafonne le levier max à 20x (vs 50x autorisé)
+                $maxLev = min($maxLev, self::HC_DEFAULT_LEV_CAP);
+                $targetLev = (int)($maxLev * 0.2);
+            } else {
+
+            }
+            $targetLev = (int)($maxLev * 0.1);
             $this->positionsLogger->info("Leverage calculation", [
                 'lev_from_budget' => $levFromSizing,
                 'lev_floor_2x'    => $levFloor,
@@ -1025,234 +1041,369 @@
         try {
             $side = strtoupper($finalSideUpper);
 
-        $this->positionsLogger->info('[SR] Étape 1: Récupération des détails du contrat', [
-            'symbol' => $symbol
-        ]);
-        $details = $this->getContractDetails($symbol);
-        $tick    = (float)($details['price_precision'] ?? 0.0);
-        $qtyStep = (float)($details['vol_precision']   ?? 0.0);
-        $ctSize  = (float)($details['contract_size']   ?? 0.0);
-        $maxLev  = (int)  ($details['max_leverage']    ?? 50);
+            // ===== Étape 1: Détails contrat =====
+            $this->positionsLogger->info('[SR] Étape 1: Récupération des détails du contrat', [
+                'symbol' => $symbol
+            ]);
+            $details = $this->getContractDetails($symbol);
+            $tick    = (float)($details['price_precision'] ?? 0.0);
+            $qtyStep = (float)($details['vol_precision']   ?? 0.0);
+            $ctSize  = (float)($details['contract_size']   ?? 0.0);
+            $maxLev  = (int)  ($details['max_leverage']    ?? 50);
 
-        if ($tick <= 0 || $qtyStep <= 0 || $ctSize <= 0) {
-            $this->positionsLogger->error('[SR] Détails contrat invalides', compact('tick', 'qtyStep', 'ctSize'));
-            throw new \RuntimeException("Invalid contract details for $symbol");
-        }
+            if ($tick <= 0 || $qtyStep <= 0 || $ctSize <= 0) {
+                $this->positionsLogger->error('[SR] Détails contrat invalides', compact('tick', 'qtyStep', 'ctSize'));
+                throw new \RuntimeException("Invalid contract details for $symbol");
+            }
 
-        $this->positionsLogger->info('[SR] Étape 2: Récupération du prix mark', [
-            'symbol' => $symbol
-        ]);
-        $mark  = $this->getMarkClose($symbol);
-        $limit = $this->quantizeToStep($mark, $tick);
-        $this->positionsLogger->info('[SR] Prix d\'entrée arrondi', [
-            'mark' => $mark,
-            'limit' => $limit
-        ]);
+            // ===== Étape 2: Prix mark & entrée =====
+            $this->positionsLogger->info('[SR] Étape 2: Récupération du prix mark', ['symbol' => $symbol]);
+            $mark  = $this->getMarkClose($symbol);
+            $limit = $this->quantizeToStep($mark, $tick);
+            $this->positionsLogger->info('[SR] Prix d\'entrée arrondi', ['mark' => $mark, 'limit' => $limit]);
 
-        $cfg = $this->tradingParameters->all();
-        $atrLookback  = (int)($cfg['atr']['lookback'] ?? 14);
-        $atrMethod    = (string)($cfg['atr']['method'] ?? 'wilder');
-        $atrTimeframe = (string)($cfg['atr']['timeframe'] ?? '5m');
-        $atrSeries = $this->klineRepository->findLastKlines(
-            symbol: $symbol,
-            timeframe: $atrTimeframe,
-            limit: max($atrLookback + 1, 200)
-        );
-        if (count($atrSeries) <= $atrLookback) {
-            $this->positionsLogger->error('[SR] Pas assez de bougies pour l\'ATR', [
-                'timeframe' => $atrTimeframe,
-                'count'     => count($atrSeries),
-                'lookback'  => $atrLookback
-            ]);
-            throw new \RuntimeException("Not enough OHLC for ATR ($symbol tf=$atrTimeframe)");
-        }
-        $atrValue = $this->atrCalculator->compute($atrSeries, $atrLookback, $atrMethod);
-        $this->positionsLogger->info('[SR] ATR source', [
-            'timeframe' => $atrTimeframe,
-            'lookback'  => $atrLookback,
-            'atr'       => $atrValue
-        ]);
+            // ===== Config & ATR =====
+            $cfg = $this->tradingParameters->all();
+            $atrLookback  = (int)($cfg['atr']['lookback'] ?? 14);
+            $atrMethod    = (string)($cfg['atr']['method'] ?? 'wilder');
+            $atrTimeframe = (string)($cfg['atr']['timeframe'] ?? '5m');
+
+            $atrSeries = $this->klineRepository->findLastKlines(
+                symbol: $symbol,
+                timeframe: $atrTimeframe,
+                limit: max($atrLookback + 1, 200)
+            );
+            if (count($atrSeries) <= $atrLookback) {
+                $this->positionsLogger->error('[SR] Pas assez de bougies pour l\'ATR', [
+                    'timeframe' => $atrTimeframe,
+                    'count'     => count($atrSeries),
+                    'lookback'  => $atrLookback
+                ]);
+                throw new \RuntimeException("Not enough OHLC for ATR ($symbol tf=$atrTimeframe)");
+            }
+            $atrValue = $this->atrCalculator->compute($atrSeries, $atrLookback, $atrMethod);
+            $this->positionsLogger->info('[SR] ATR source', [
+                'timeframe' => $atrTimeframe,
+                'lookback'  => $atrLookback,
+                'atr'       => $atrValue
+            ]);
+            // ATR exprimé en % du prix d'entrée (pour buffer k*ATR%)
+            $atrPct = $atrValue / max(1e-12, $mark);
 
-        $this->positionsLogger->info('[SR] Étape 3: Chargement des klines pour S/R', [
-            'symbol' => $symbol
-        ]);
-        $klines15m = $this->klineRepository->findLastKlines(
-            symbol: $symbol,
-            timeframe: '15m',
-            limit: 200
-        );
-
-        if (count($klines15m) < 50) {
-            $this->positionsLogger->error('[SR] Pas assez de klines pour la détection S/R', [
-                'count' => count($klines15m)
-            ]);
-            throw new \RuntimeException("Not enough klines for SR detection ($symbol)");
-        }
-        // Log de la date du dernier kline et de la date courante alignée
-        $lastKline = end($klines15m);
-        $lastOpen  = $lastKline['open_time'] ?? null; // adapte si ta BDD stocke différemment
-        if ($lastOpen !== null) {
-            $lastOpenDt = (new \DateTimeImmutable())->setTimestamp((int)$lastOpen)->setTimezone(new \DateTimeZone('UTC'));
-            $alignedDt  = \App\Util\TimeframeHelper::getAlignedOpen('15m');
-
-            $this->positionsLogger->info('[SR] Comparaison temps klines', [
-                'last_kline_open' => $lastOpenDt->format('Y-m-d H:i:s T'),
-                'aligned_now'     => $alignedDt->format('Y-m-d H:i:s T'),
-                'now_utc'         => (new \DateTimeImmutable('now', new \DateTimeZone('UTC')))->format('Y-m-d H:i:s T'),
-            ]);
-        }
+            // ===== Étape 3: Kliness pour S/R =====
+            $this->positionsLogger->info('[SR] Étape 3: Chargement des klines pour S/R', ['symbol' => $symbol]);
+            $klines15m = $this->klineRepository->findLastKlines(
+                symbol: $symbol,
+                timeframe: '15m',
+                limit: 200
+            );
+            if (count($klines15m) < 50) {
+                $this->positionsLogger->error('[SR] Pas assez de klines pour la détection S/R', [
+                    'count' => count($klines15m)
+                ]);
+                throw new \RuntimeException("Not enough klines for SR detection ($symbol)");
+            }
+
+            // Log de contrôle temporel
+            $lastKline = end($klines15m);
+            $lastOpen  = $lastKline['open_time'] ?? null; // adapte si ta BDD stocke différemment
+            if ($lastOpen !== null) {
+                $lastOpenDt = (new \DateTimeImmutable())->setTimestamp((int)$lastOpen)->setTimezone(new \DateTimeZone('UTC'));
+                $alignedDt  = \App\Util\TimeframeHelper::getAlignedOpen('15m');
+                $this->positionsLogger->info('[SR] Comparaison temps klines', [
+                    'last_kline_open' => $lastOpenDt->format('Y-m-d H:i:s T'),
+                    'aligned_now'     => $alignedDt->format('Y-m-d H:i:s T'),
+                    'now_utc'         => (new \DateTimeImmutable('now', new \DateTimeZone('UTC')))->format('Y-m-d H:i:s T'),
+                ]);
+            }
 
+            // ===== Étape 4: Détection S/R (service) =====
+            $this->positionsLogger->info('[SR] Étape 4: Détection S/R (service)');
+            $srLevels = $this->srService->compute($klines15m, leftRight: 2, tolerancePct: 0.002);
+            $sr = [
+                'supports'    => $srLevels['supports'],
+                'resistances' => $srLevels['resistances'],
+                'atr'         => $atrValue,  // compat existante
+                'atr_pct'     => $atrPct,    // nouveau
+            ];
 
-        $this->positionsLogger->info('[SR] Étape 4: Détection S/R');
-        $sr = SrRiskHelper::findSupportResistance($klines15m);
-        $sr['atr'] = $atrValue;
-
-        $this->positionsLogger->info('[SR] Étape 5: Calcul du Stop Loss via S/R + ATR', [
-            'side' => $side,
-            'limit' => $limit,
-            'supports' => $sr['supports'],
-            'resistances' => $sr['resistances'],
-            'atr' => $sr['atr'],
-            'atr_tf' => $atrTimeframe
-        ]);
-        $slRaw = SrRiskHelper::chooseSlFromSr($side, $limit, $sr['supports'], $sr['resistances'], $sr['atr']);
-        $slQ   = $this->quantizeToStep($slRaw, $tick);
+            // ===== Étape 5: SL via S/R + buffer ATR =====
+            $this->positionsLogger->info('[SR] Étape 5: Calcul du Stop Loss via S/R + ATR', [
+                'side'        => $side,
+                'limit'       => $limit,
+                'supports'    => $sr['supports'],
+                'resistances' => $sr['resistances'],
+                'atr'         => $sr['atr'],
+                'atr_tf'      => $atrTimeframe
+            ]);
+            $slRaw = SrRiskHelper::chooseSlFromSr($side, $limit, $sr['supports'], $sr['resistances'], $sr['atr']);
+
+            // Buffer minimal k*ATR% si le SL issu de S/R est trop serré
+            $kBuffer     = (float)($cfg['atr']['k_buffer'] ?? 1.0); // ex: 1.0 = 1×ATR
+            $stopPct0    = abs($slRaw - $limit) / $limit;
+            $minStopPct  = $kBuffer * $atrPct;
+            if ($stopPct0 < $minStopPct) {
+                $slRaw = ($side === 'LONG')
+                    ? $limit * (1.0 - $minStopPct)
+                    : $limit * (1.0 + $minStopPct);
+                $this->positionsLogger->info('[SR] SL ajusté par buffer ATR', [
+                    'k_buffer'   => $kBuffer,
+                    'atr_pct'    => $atrPct,
+                    'minStopPct' => $minStopPct,
+                ]);
+            }
+            $slQ = $this->quantizeToStep($slRaw, $tick);
+            // empêcher un SL collé au prix d'entrée après quantization
+            if (abs($slQ - $limit) < max($tick, 1e-12)) {
+                $slQ = ($side === 'LONG') ? $limit - $tick : $limit + $tick;
+            }
 
-        $this->positionsLogger->info('[SR] Étape 6: Calcul du levier optimal', [
-            'limit' => $limit,
-            'slQ' => $slQ,
-            'riskMaxPct' => $riskMaxPct,
-            'maxLev' => $maxLev
-        ]);
-        $levOptFloat = SrRiskHelper::leverageFromRisk($limit, $slQ, $riskMaxPct, $maxLev);
-        $levFinal    = max(1, min($maxLev, (int)ceil($levOptFloat)));
+            // ===== Étape 6: Levier optimal (risk-based ∧ dynamique) =====
+            $this->positionsLogger->info('[SR] Étape 6: Calcul du levier optimal', [
+                'limit'      => $limit,
+                'slQ'        => $slQ,
+                'riskMaxPct' => $riskMaxPct,
+                'maxLev'     => $maxLev
+            ]);
+
+            // Cap spécifique BTC/ETH (règle conservée)
+            if (preg_match('/^(BTC|ETH)/', $symbol)) {
+                $maxLev = min($maxLev, self::HC_DEFAULT_LEV_CAP);
+                $this->positionsLogger->info('[SR] Cap BTC/ETH appliqué', ['maxLev' => $maxLev]);
+            }
+
+            $levOptFloat = SrRiskHelper::leverageFromRisk($limit, $slQ, $riskMaxPct, $maxLev);
+            $levFromRisk = (int)ceil(max(1.0, min((float)$maxLev, $levOptFloat)));
 
+            // Règle dynamique complémentaire: levier_cible = min(maxLev, k / (%stop))
+            $stopPct = abs($slQ - $limit) / $limit;
+            $kDyn     = (float)($cfg['leverage']['k']     ?? 10.0); // ex: 10
+            $levFloor = (int)  ($cfg['leverage']['floor'] ?? 2);    // ex: 2x
+            $levDyn   = (int)ceil($kDyn / max(1e-6, $stopPct * 100.0));
+            $levDyn   = max($levFloor, min($maxLev, $levDyn));
 
-        $this->positionsLogger->info('[SR] Étape 7: Calcul du Take Profit (R-multiple)', [
-            'rMultiple' => $rMultiple
-        ]);
-        $stopPct = abs($slQ - $limit) / $limit;
-        $tpTarget = $stopPct * $rMultiple;
-        $tpRaw = ($side === 'LONG')
-            ? $limit * (1.0 + $tpTarget)
-            : $limit * (1.0 - $tpTarget);
-        $tpQ = $this->quantizeToStep($tpRaw, $tick);
+            $levFinal = min($levFromRisk, $levDyn);
+            $this->positionsLogger->info('[SR] Levier final (risk ∧ dynamique)', [
+                'levFromRisk' => $levFromRisk,
+                'levDyn'      => $levDyn,
+                'levFinal'    => $levFinal,
+                'stopPct'     => $stopPct,
+            ]);
+
+            // ===== Étape 7: Take Profit (R-multiple) =====
+            $this->positionsLogger->info('[SR] Étape 7: Calcul du Take Profit (R-multiple)', [
+                'rMultiple' => $rMultiple
+            ]);
+            // recalcul stopPct au cas où le SL a changé
+            $stopPct  = abs($slQ - $limit) / $limit;
+            $tpTarget = $stopPct * $rMultiple;
+            $tpRaw = ($side === 'LONG')
+                ? $limit * (1.0 + $tpTarget)
+                : $limit * (1.0 - $tpTarget);
+            $tpQ = $this->quantizeToStep($tpRaw, $tick);
+            // empêcher un TP collé au prix d'entrée après quantization
+            if (abs($tpQ - $limit) < max($tick, 1e-12)) {
+                $tpQ = ($side === 'LONG') ? $limit + $tick : $limit - $tick;
+            }
 
-        $this->positionsLogger->info('[SR] Étape 8: Sizing de la position', [
-            'marginUsdt' => $marginUsdt,
-            'levOpt' => $levFinal,
-            'limit' => $limit,
-            'ctSize' => $ctSize,
-            'qtyStep' => $qtyStep
-        ]);
-        $notionalMax = $marginUsdt * $levFinal;
-        $contractsBud = $this->quantizeQty(
-            $notionalMax / max(1e-12, $limit * $ctSize),
-            max(1e-9, $qtyStep)
-        );
-        $contracts = (int)max(1, $contractsBud);
+            // ===== Étape 8: Sizing =====
+            $this->positionsLogger->info('[SR] Étape 8: Sizing de la position', [
+                'marginUsdt' => $marginUsdt,
+                'levOpt'     => $levFinal,
+                'limit'      => $limit,
+                'ctSize'     => $ctSize,
+                'qtyStep'    => $qtyStep
+            ]);
+            $notionalMax  = $marginUsdt * $levFinal;
+            $contractsBud = $this->quantizeQty(
+                $notionalMax / max(1e-12, $limit * $ctSize),
+                max(1e-9, $qtyStep)
+            );
+            $contracts = (int)max(1, $contractsBud);
 
-        $this->positionsLogger->info('[SR] Étape 9: Fixe le levier', [
-            'levOpt' => ceil($levFinal)
-        ]);
-        $this->bitmartPositions->setLeverage($symbol, $levFinal, 'isolated');
-        $this->waitLeverageSynchronized($symbol, $levFinal, 'isolated');
+            // ===== Étape 9: Fixe levier (isolated) =====
+            $this->positionsLogger->info('[SR] Étape 9: Fixe le levier', ['levOpt' => ceil($levFinal)]);
+            $this->bitmartPositions->setLeverage($symbol, $levFinal, 'isolated');
+            $this->waitLeverageSynchronized($symbol, $levFinal, 'isolated'); // idempotence: vérifier avant submit
 
-        $clientOrderId = 'SR_' . bin2hex(random_bytes(6));
-        $payload = [
-            'symbol'                        => $symbol,
-            'client_order_id'               => $clientOrderId,
-            'side'                          => $this->mapSideOpen(strtolower($side)),
-            'mode'                          => 1,
-            'type'                          => 'limit',
-            'open_type'                     => 'isolated',
-            'leverage'                      => (string)$levFinal,
-            'size'                          => $contracts,
-            'price'                         => (string)$limit,
-            'preset_take_profit_price_type' => 2,
-            'preset_stop_loss_price_type'   => 2,
-            'preset_take_profit_price'      => (string)$tpQ,
-            'preset_stop_loss_price'        => (string)$slQ,
-            'stp_mode'                      => 1,
-        ];
+            // ===== Étape 10: Submit ordre limite + presets TP/SL =====
+            $clientOrderId = 'SR_' . bin2hex(random_bytes(6));
+            $payload = [
+                'symbol'                        => $symbol,
+                'client_order_id'               => $clientOrderId,
+                'side'                          => $this->mapSideOpen(strtolower($side)),
+                'mode'                          => 1,
+                'type'                          => 'limit',
+                'open_type'                     => 'isolated',
+                'leverage'                      => (string)$levFinal,
+                'size'                          => $contracts,
+                'price'                         => (string)$limit,
+                'preset_take_profit_price_type' => 2,
+                'preset_stop_loss_price_type'   => 2,
+                'preset_take_profit_price'      => (string)$tpQ,
+                'preset_stop_loss_price'        => (string)$slQ,
+                'stp_mode'                      => 1,
+            ];
 
-        $this->positionsLogger->info('[SR] Étape 10: Soumission de l\'ordre', $payload);
-        $res = $this->ordersService->create($payload);
-        // Mise à jour du pipeline
-        try {
-            $this->pipelineRepository->updateStatusBySymbol(
-                symbol: $symbol,
-                status: ContractPipeline::STATUS_ORDER_OPENED
-            );
-            $this->positionsLogger->info('[SR] Pipeline mis à jour -> STATUS_ORDER_OPENED', [
-                'symbol' => $symbol,
-                'order_id' => $res['data']['order_id'] ?? null,
-                'status' => ContractPipeline::STATUS_ORDER_OPENED
-            ]);
-        } catch (\Throwable $e) {
-            $this->positionsLogger->error('[SR] Erreur lors de la mise à jour du pipeline', [
-                'symbol' => $symbol,
-                'error' => $e->getMessage()
-            ]);
-        }
+            // 11) D'ABORD créer l'ordre en BDD (statut NEW avant submit)
+            $pipelineId = $this->getPipelineIdForSymbol($symbol);
+            $reqDto = new SubmitOrderRequestDto(
+                symbol: $symbol,
+                clientOrderId: $clientOrderId,
+                side: $this->mapSideOpen(strtolower($side)),
+                mode: 1,
+                type: 'limit',
+                size: (string) $contracts,
+                price: (string) $limit,
+                leverage: $levFinal,
+                openType: 'isolated'
+            );
+
+            $order = OrderHydrator::createFromSubmitRequest(
+                req: $reqDto,
+                contractPipelineId: (string) $pipelineId,
+                side: $side === 'LONG' ? Side::LONG : Side::SHORT,
+                type: OrderType::LIMIT,
+                stopLossPrice: $slQ,
+                takeProfitPrice: $tpQ,
+                leverage: $levFinal,
+                openType: OrderOpenType::ISOLATED
+            );
+
+            $this->entityManager->persist($order);
+            $this->entityManager->flush();
+
+            $this->positionsLogger->info('[SR] Ordre créé en BDD (statut NEW)', [
+                'order_id_local' => $order->id(),
+                'client_order_id' => $clientOrderId,
+            ]);
+
+            // 12) Soumission à l'exchange
+            $this->positionsLogger->info('[SR] Étape 10: Soumission de l\'ordre', $payload);
+
+            try {
+                $res = $this->ordersService->create($payload);
+                $this->positionsLogger->info('[SR] Réponse de l\'API BitMart', $res);
+
+                if (($res['code'] ?? 0) !== 1000) {
+                    // Erreur métier de l'API
+                    $errorMsg = $res['message'] ?? json_encode($res, JSON_UNESCAPED_SLASHES);
+                    OrderHydrator::onSubmitFailure(
+                        order: $order,
+                        errorMessage: $errorMsg,
+                        serverTimeMs: null,
+                        httpStatus: null,
+                        exchangeCode: $res['code'] ?? null
+                    );
+                    $this->entityManager->flush();
+                    $this->positionsLogger->error('[SR] Erreur lors de la soumission de l\'ordre', ['response' => $res]);
+                    throw new \RuntimeException('submit-order error: ' . $errorMsg);
+                }
+
+                $orderId = $res['data']['order_id'] ?? null;
+                if (empty($orderId)) {
+                    OrderHydrator::onSubmitFailure(
+                        order: $order,
+                        errorMessage: 'Missing order_id in response',
+                        serverTimeMs: null,
+                        httpStatus: null,
+                        exchangeCode: $res['code'] ?? null
+                    );
+                    $this->entityManager->flush();
+                    $this->positionsLogger->error('[SR] order_id manquant — arrêt pipeline');
+                    throw new \RuntimeException('submit-order: missing order_id');
+                }
+
+                // Succès : marquer l'ordre comme soumis
+                $responseDto = new SubmitOrderResponseDto(
+                    orderId: $orderId,
+                    serverTimeMs: null
+                );
+                OrderHydrator::onSubmitResponse($order, $responseDto);
+                $this->entityManager->flush();
+
+            } catch (\RuntimeException $e) {
+                throw $e; // Re-throw RuntimeException déjà tracé
+            } catch (\Throwable $e) {
+                // Erreur technique (réseau, timeout, etc.)
+                OrderHydrator::onSubmitException($order, $e);
+                $this->entityManager->flush();
+                $this->positionsLogger->error('[SR] Exception lors de la soumission', [
+                    'error' => $e->getMessage(),
+                    'trace' => $e->getTraceAsString()
+                ]);
+                throw $e;
+            }
+
+            // Pipeline
+            try {
+                $this->pipelineRepository->updateStatusBySymbol(
+                    symbol: $symbol,
+                    status: ContractPipeline::STATUS_ORDER_OPENED
+                );
+                $this->positionsLogger->info('[SR] Pipeline mis à jour -> STATUS_ORDER_OPENED', [
+                    'symbol'   => $symbol,
+                    'order_id' => $orderId,
+                    'status'   => ContractPipeline::STATUS_ORDER_OPENED
+                ]);
+            } catch (\Throwable $e) {
+                $this->positionsLogger->error('[SR] Erreur lors de la mise à jour du pipeline', [
+                    'symbol' => $symbol,
+                    'error'  => $e->getMessage()
+                ]);
+            }
 
-        $this->positionsLogger->info('[SR] Réponse de l\'API BitMart', $res);
-        if (($res['code'] ?? 0) !== 1000) {
-            $this->positionsLogger->error('[SR] Erreur lors de la soumission de l\'ordre', [
-                'response' => $res
-            ]);
-            throw new \RuntimeException('submit-order error: ' . json_encode($res, JSON_UNESCAPED_SLASHES));
-        }
-        $orderId = $res['data']['order_id'] ?? null;
-
-        if ($expireAfterSec !== null) {
-            $this->positionsLogger->info('[SR] Étape 11: Programmation de l\'expiration auto', [
-                'expireAfterSec' => $expireAfterSec
-            ]);
-            try {
-                $this->trailOrders->cancelAllAfter($symbol, $expireAfterSec);
-            } catch (\Throwable $e) {
-                $this->positionsLogger->warning('scheduleCancelAllAfter failed', [
-                    'symbol' => $symbol,
-                    'timeout' => $expireAfterSec,
-                    'error' => $e->getMessage()
-                ]);
-            }
-        }
+            // ===== Étape 11: Expiration auto (optionnelle) =====
+            if ($expireAfterSec !== null) {
+                $this->positionsLogger->info('[SR] Étape 11: Programmation de l\'expiration auto', [
+                    'expireAfterSec' => $expireAfterSec
+                ]);
+                try {
+                    $this->trailOrders->cancelAllAfter($symbol, $expireAfterSec);
+                } catch (\Throwable $e) {
+                    $this->positionsLogger->warning('scheduleCancelAllAfter failed', [
+                        'symbol'  => $symbol,
+                        'timeout' => $expireAfterSec,
+                        'error'   => $e->getMessage()
+                    ]);
+                }
+            }
 
-        $this->positionsLogger->info('[SR] Étape 12: Retour final', [
-            'symbol'     => $symbol,
-            'side'       => $side,
-            'order_id'   => $orderId,
-            'client_order_id' => $clientOrderId,
-            'limit'      => $limit,
-            'sl'         => $slQ,
-            'tp'         => $tpQ,
-            'contracts'  => $contracts,
-            'leverage'   => $levFinal,
-            'metrics'    => $sr,
-            'meta'       => $meta,
-        ]);
+            // ===== Étape 12: Retour =====
+            $this->positionsLogger->info('[SR] Étape 12: Retour final', [
+                'symbol'          => $symbol,
+                'side'            => $side,
+                'order_id'        => $orderId,
+                'client_order_id' => $clientOrderId,
+                'limit'           => $limit,
+                'sl'              => $slQ,
+                'tp'              => $tpQ,
+                'contracts'       => $contracts,
+                'leverage'        => $levFinal,
+                'metrics'         => $sr,
+                'meta'            => $meta,
+            ]);
 
-        return [
-            'symbol'     => $symbol,
-            'side'       => $side,
-            'order_id'   => $orderId,
-            'client_order_id' => $clientOrderId,
-            'limit'      => $limit,
-            'sl'         => $slQ,
-            'tp'         => $tpQ,
-            'contracts'  => $contracts,
-            'leverage'   => $levFinal,
-            'metrics'    => $sr,
-            'meta'       => $meta,
-        ];
+            return [
+                'symbol'          => $symbol,
+                'side'            => $side,
+                'order_id'        => $orderId,
+                'client_order_id' => $clientOrderId,
+                'limit'           => $limit,
+                'sl'              => $slQ,
+                'tp'              => $tpQ,
+                'contracts'       => $contracts,
+                'leverage'        => $levFinal,
+                'metrics'         => $sr,
+                'meta'            => $meta,
+            ];
         } finally {
             $this->persistOrderId($symbol, $orderId, '[SR]');
         }
     }
 
 
+
     /**
      * Variante HIGH CONVICTION :
      * - Même logique S/R + ATR que openLimitAutoLevWithSr()
@@ -1335,7 +1486,7 @@
             'supports' => $sr['supports'], 'resistances' => $sr['resistances'], 'atr' => $sr['atr'],
             'atr_tf' => $atrTimeframe
         ]);
-        $slRaw = \App\Util\SrRiskHelper::chooseSlFromSr($side, $limit, $sr['supports'], $sr['resistances'], $sr['atr']);
+        $slRaw = SrRiskHelper::chooseSlFromSr($side, $limit, $sr['supports'], $sr['resistances'], $sr['atr']);
         $slQ   = $this->quantizeToStep($slRaw, $tick);
 
         // 5) Levier optimal basé risque ⇒ borné par CAP HC et par maxLev exchange
@@ -1408,13 +1559,95 @@
             'stp_mode'                      => 1,
         ];
 
+        // D'ABORD créer l'ordre en BDD (statut NEW avant submit)
+        $pipelineId = $this->getPipelineIdForSymbol($symbol);
+        $reqDto = new SubmitOrderRequestDto(
+            symbol: $symbol,
+            clientOrderId: $clientOrderId,
+            side: $this->mapSideOpen(strtolower($side)),
+            mode: 1,
+            type: 'limit',
+            size: (string) $contracts,
+            price: (string) $limit,
+            leverage: $levOpt,
+            openType: 'isolated'
+        );
+
+        $order = OrderHydrator::createFromSubmitRequest(
+            req: $reqDto,
+            contractPipelineId: (string) $pipelineId,
+            side: $side === 'LONG' ? Side::LONG : Side::SHORT,
+            type: OrderType::LIMIT,
+            stopLossPrice: $slQ,
+            takeProfitPrice: $tpQ,
+            leverage: $levOpt,
+            openType: OrderOpenType::ISOLATED
+        );
+
+        $this->entityManager->persist($order);
+        $this->entityManager->flush();
+
+        $this->positionsLogger->info('[HC] Ordre créé en BDD (statut NEW)', [
+            'order_id_local' => $order->id(),
+            'client_order_id' => $clientOrderId,
+        ]);
+
+        // Soumission à l'exchange
         $this->positionsLogger->info('[HC] Étape 10: Soumission ordre', $payload);
-        $res = $this->ordersService->create($payload);
-        if (($res['code'] ?? 0) !== 1000) {
-            $this->positionsLogger->error('[HC] submit-order error', ['response' => $res]);
-            throw new RuntimeException('submit-order error: ' . json_encode($res, JSON_UNESCAPED_SLASHES));
-        }
-        $orderId = $res['data']['order_id'] ?? null;
+
+        try {
+            $res = $this->ordersService->create($payload);
+            $this->positionsLogger->info('[HC] Réponse de l\'API BitMart', $res);
+
+            if (($res['code'] ?? 0) !== 1000) {
+                // Erreur métier de l'API
+                $errorMsg = $res['message'] ?? json_encode($res, JSON_UNESCAPED_SLASHES);
+                OrderHydrator::onSubmitFailure(
+                    order: $order,
+                    errorMessage: $errorMsg,
+                    serverTimeMs: null,
+                    httpStatus: null,
+                    exchangeCode: $res['code'] ?? null
+                );
+                $this->entityManager->flush();
+                $this->positionsLogger->error('[HC] submit-order error', ['response' => $res]);
+                throw new RuntimeException('submit-order error: ' . $errorMsg);
+            }
+
+            $orderId = $res['data']['order_id'] ?? null;
+            if (empty($orderId)) {
+                OrderHydrator::onSubmitFailure(
+                    order: $order,
+                    errorMessage: 'Missing order_id in response',
+                    serverTimeMs: null,
+                    httpStatus: null,
+                    exchangeCode: $res['code'] ?? null
+                );
+                $this->entityManager->flush();
+                $this->positionsLogger->error('[HC] order_id manquant');
+                throw new RuntimeException('submit-order: missing order_id');
+            }
+
+            // Succès : marquer l'ordre comme soumis
+            $responseDto = new SubmitOrderResponseDto(
+                orderId: $orderId,
+                serverTimeMs: null
+            );
+            OrderHydrator::onSubmitResponse($order, $responseDto);
+            $this->entityManager->flush();
+
+        } catch (RuntimeException $e) {
+            throw $e; // Re-throw RuntimeException déjà tracé
+        } catch (\Throwable $e) {
+            // Erreur technique (réseau, timeout, etc.)
+            OrderHydrator::onSubmitException($order, $e);
+            $this->entityManager->flush();
+            $this->positionsLogger->error('[HC] Exception lors de la soumission', [
+                'error' => $e->getMessage(),
+                'trace' => $e->getTraceAsString()
+            ]);
+            throw $e;
+        }
 
         // 11) Expiration auto (facultatif)
         if ($expireAfterSec !== null) {
@@ -1534,5 +1767,14 @@
         $this->setLeverage($symbol, $expected, $openType);
     }
 
+    private function getPipelineIdForSymbol(string $symbol)
+    {
+        $pipeline = $this->pipelineRepository->findOneBy(['symbol' => $symbol]);
+        if ($pipeline === null) {
+            throw new \RuntimeException("No ContractPipeline found for symbol $symbol");
+        }
+        return $pipeline->getId();
+    }
+
 
 }
Index: symfony-app/src/Service/Bitmart/BitmartRefreshService.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Service\\Bitmart;\n\nuse App\\Service\\Temporal\\Dto\\WorkflowRef;\nuse App\\Service\\Temporal\\Orchestrators\\BitmartOrchestrator;\nuse App\\Util\\TimeframeHelper;\n\nfinal class BitmartRefreshService\n{\n    private const BASE_URL = 'http://nginx';\n    private const CALLBACK = 'api/callback/bitmart/get-kline';\n    private const LIMIT_KLINES = 260;\n\n    public function __construct(private readonly BitmartOrchestrator $bitmartOrchestrator)\n    {\n    }\n\n    public function refreshSingle(string $symbol, string $timeframe, ?int $limit = null): void\n    {\n        $limit = $limit ?? self::LIMIT_KLINES;\n        $tfMinutes = TimeframeHelper::parseTimeframeToMinutes($timeframe);\n        $cutoff = TimeframeHelper::getAlignedOpenByMinutes($tfMinutes);\n        $start = $cutoff->modify('-' . ($limit - 1) * $tfMinutes . ' minutes');\n\n        $workflowRef = new WorkflowRef('api-rate-limiter-workflow', 'ApiRateLimiterClient', 'api_rate_limiter_queue');\n        $batchId = sprintf('refresh-%s-%s', strtolower($symbol), (new \\DateTimeImmutable())->format('YmdHisv'));\n        $this->bitmartOrchestrator->reset();\n        $this->bitmartOrchestrator->setWorkflowRef($workflowRef);\n\n        $this->bitmartOrchestrator->requestGetKlines(\n            $workflowRef,\n            baseUrl: self::BASE_URL,\n            callback: self::CALLBACK,\n            contract: $symbol,\n            timeframe: $timeframe,\n            limit: $limit,\n            start: $start,\n            end: $cutoff,\n            note: 'auto-refresh',\n            batchId: $batchId\n        );\n\n        $this->bitmartOrchestrator->go();\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Service/Bitmart/BitmartRefreshService.php b/symfony-app/src/Service/Bitmart/BitmartRefreshService.php
--- a/symfony-app/src/Service/Bitmart/BitmartRefreshService.php	(revision acfe8edc4f51e920bc6e35643a19748aa79bb144)
+++ b/symfony-app/src/Service/Bitmart/BitmartRefreshService.php	(date 1759583239182)
@@ -14,12 +14,20 @@
     private const CALLBACK = 'api/callback/bitmart/get-kline';
     private const LIMIT_KLINES = 260;
 
-    public function __construct(private readonly BitmartOrchestrator $bitmartOrchestrator)
+    public function __construct(
+        private readonly BitmartOrchestrator $bitmartOrchestrator,
+        private readonly BlacklistService $blacklistService,
+    )
     {
     }
 
     public function refreshSingle(string $symbol, string $timeframe, ?int $limit = null): void
     {
+        // 1) Skip si blacklist
+        if ($this->blacklistService->isBlacklisted($symbol)) {
+            // log: symbole ignoré (blacklist/no_response_streak>=6)
+            return;
+        }
         $limit = $limit ?? self::LIMIT_KLINES;
         $tfMinutes = TimeframeHelper::parseTimeframeToMinutes($timeframe);
         $cutoff = TimeframeHelper::getAlignedOpenByMinutes($tfMinutes);
Index: symfony-app/.env
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># In all environments, the following files are loaded if they exist,\n# the latter taking precedence over the former:\n#\n#  * .env                contains default values for the environment variables needed by the app\n#  * .env.local          uncommitted file with local overrides\n#  * .env.$APP_ENV       committed environment-specific defaults\n#  * .env.$APP_ENV.local uncommitted environment-specific overrides\n#\n# Real environment variables win over .env files.\n#\n# DO NOT DEFINE PRODUCTION SECRETS IN THIS FILE NOR IN ANY OTHER COMMITTED FILES.\n# https://symfony.com/doc/current/configuration/secrets.html\n#\n# Run \"composer dump-env prod\" to compile .env files for production use (requires symfony/flex >=1.2).\n# https://symfony.com/doc/current/best_practices.html#use-environment-variables-for-infrastructure-configuration\nPYTHON_API_BASE_URL=http://python:8000\n###> symfony/framework-bundle ###\nAPP_ENV=dev\nAPP_SECRET=\n###< symfony/framework-bundle ###\n\n###> doctrine/doctrine-bundle ###\nDATABASE_URL=\"mysql://symfony:symfony@db:3306/symfony_db\"\n###< doctrine/doctrine-bundle ###\n\n###> nelmio/cors-bundle ###\nCORS_ALLOW_ORIGIN='^https?://(localhost|127\\.0\\.0\\.1)(:[0-9]+)?$'\n###< nelmio/cors-bundle ###\nINDICATOR_BASE=http://indicator_api:8000\n\nBITMART_BASE_URL=https://api-cloud-v2.bitmart.com\n\nBITMART_API_KEY=5674049d93282e052f06b7d5d16e3eec2397509b\nBITMART_SECRET_KEY=bba7745759a75edf7c5e97a835b86e06fdab734dfdc0714c66a7f40fe564d8c5\nBITMART_API_MEMO=tradingV3\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/.env b/symfony-app/.env
--- a/symfony-app/.env	(revision acfe8edc4f51e920bc6e35643a19748aa79bb144)
+++ b/symfony-app/.env	(date 1759614619172)
@@ -34,3 +34,9 @@
 BITMART_SECRET_KEY=bba7745759a75edf7c5e97a835b86e06fdab734dfdc0714c66a7f40fe564d8c5
 BITMART_API_MEMO=tradingV3
 
+
+###> symfony/lock ###
+# Choose one of the stores below
+# postgresql+advisory://db_user:db_password@localhost/db_name
+LOCK_DSN=flock
+###< symfony/lock ###
Index: symfony-app/src/Service/Indicator/SupportResistanceService.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Service/Indicator/SupportResistanceService.php b/symfony-app/src/Service/Indicator/SupportResistanceService.php
new file mode 100644
--- /dev/null	(date 1759575690184)
+++ b/symfony-app/src/Service/Indicator/SupportResistanceService.php	(date 1759575690184)
@@ -0,0 +1,199 @@
+<?php
+// src/Service/Indicator/SupportResistanceService.php
+
+declare(strict_types=1);
+
+namespace App\Service\Indicator;
+
+final class SupportResistanceService
+{
+    /**
+     * Kline attendue: tableau d'items associatifs avec clés:
+     * ['ts'=>int, 'open'=>float, 'high'=>float, 'low'=>float, 'close'=>float, 'volume'=>float]
+     * Ordre conseillé: croissant par ts.
+     */
+
+    /**
+     * Détecte swing highs/lows (structure de marché).
+     * $leftRight = nb de bougies de part et d'autre (ex: 2 signifie un pivot entouré de 2 barres).
+     *
+     * @return array{highs: array<int, array{price: float, ts:int, i:int}>, lows: array<int, array{price: float, ts:int, i:int}>}
+     */
+    public function detectSwings(array $klines, int $leftRight = 2): array
+    {
+        $n = count($klines);
+        $highs = [];
+        $lows  = [];
+
+        for ($i = $leftRight; $i < $n - $leftRight; $i++) {
+            $isHigh = true;
+            $isLow  = true;
+
+            $hi = (float)$klines[$i]['high'];
+            $lo = (float)$klines[$i]['low'];
+
+            for ($k = $i - $leftRight; $k <= $i + $leftRight; $k++) {
+                if ($k === $i) continue;
+                if ((float)$klines[$k]['high'] >= $hi) $isHigh = false;
+                if ((float)$klines[$k]['low']  <= $lo) $isLow  = false;
+                if (!$isHigh && !$isLow) break;
+            }
+
+            if ($isHigh) $highs[] = ['price' => $hi, 'ts' => (int)$klines[$i]['ts'], 'i' => $i];
+            if ($isLow)  $lows[]  = ['price' => $lo, 'ts' => (int)$klines[$i]['ts'], 'i' => $i];
+        }
+
+        return ['highs' => $highs, 'lows' => $lows];
+    }
+
+    /**
+     * Regroupe des niveaux proches en "zones" (tolerancePct, ex 0.002 = 0,2%).
+     * Renvoie des zones triées par force décroissante (touches) puis récence.
+     *
+     * @param array<int, array{price:float, ts:int, i:int}> $levels
+     * @return array<int, array{
+     *   price: float,        // prix moyen de la zone
+     *   min: float,          // borne basse de la zone
+     *   max: float,          // borne haute de la zone
+     *   touches: int,        // nb d'occurrences fusionnées
+     *   last_ts: int,        // dernière fois touchée
+     * }>
+     */
+    public function clusterLevels(array $levels, float $tolerancePct = 0.002): array
+    {
+        if (empty($levels)) return [];
+
+        // Tri par prix
+        usort($levels, fn($a, $b) => $a['price'] <=> $b['price']);
+
+        $clusters = [];
+        $current  = [
+            'prices'  => [$levels[0]['price']],
+            'min'     => $levels[0]['price'],
+            'max'     => $levels[0]['price'],
+            'touches' => 1,
+            'last_ts' => $levels[0]['ts'],
+        ];
+
+        for ($i = 1; $i < count($levels); $i++) {
+            $p = (float)$levels[$i]['price'];
+            $center = array_sum($current['prices']) / count($current['prices']);
+            $tol    = $center * $tolerancePct;
+
+            if (abs($p - $center) <= $tol) {
+                $current['prices'][] = $p;
+                $current['min'] = min($current['min'], $p);
+                $current['max'] = max($current['max'], $p);
+                $current['touches']++;
+                $current['last_ts'] = max($current['last_ts'], (int)$levels[$i]['ts']);
+            } else {
+                $clusters[] = [
+                    'price'   => array_sum($current['prices']) / count($current['prices']),
+                    'min'     => $current['min'],
+                    'max'     => $current['max'],
+                    'touches' => $current['touches'],
+                    'last_ts' => $current['last_ts'],
+                ];
+                // nouveau cluster
+                $current = [
+                    'prices'  => [$p],
+                    'min'     => $p,
+                    'max'     => $p,
+                    'touches' => 1,
+                    'last_ts' => (int)$levels[$i]['ts'],
+                ];
+            }
+        }
+
+        // push dernier
+        $clusters[] = [
+            'price'   => array_sum($current['prices']) / count($current['prices']),
+            'min'     => $current['min'],
+            'max'     => $current['max'],
+            'touches' => $current['touches'],
+            'last_ts' => $current['last_ts'],
+        ];
+
+        // Tri: d’abord par touches desc, puis par last_ts desc
+        usort($clusters, function ($a, $b) {
+            if ($a['touches'] !== $b['touches']) {
+                return $b['touches'] <=> $a['touches'];
+            }
+            return $b['last_ts'] <=> $a['last_ts'];
+        });
+
+        return $clusters;
+    }
+
+    /**
+     * Calcule supports & résistances à partir de swings, puis clusterise.
+     *
+     * @return array{supports: array<int, array>, resistances: array<int, array>}
+     */
+    public function compute(array $klines, int $leftRight = 2, float $tolerancePct = 0.002): array
+    {
+        $swings = $this->detectSwings($klines, $leftRight);
+        $supports    = $this->clusterLevels($swings['lows'],  $tolerancePct);
+        $resistances = $this->clusterLevels($swings['highs'], $tolerancePct);
+
+        return ['supports' => $supports, 'resistances' => $resistances];
+    }
+
+    /**
+     * Retourne le support le plus proche sous $price et la résistance la plus proche au-dessus.
+     *
+     * @param array<int, array> $supports
+     * @param array<int, array> $resistances
+     * @return array{nearest_support: ?array, nearest_resistance: ?array}
+     */
+    public function nearestLevels(float $price, array $supports, array $resistances): array
+    {
+        $nearestSupport    = null;
+        $nearestResistance = null;
+        $minDiffDown = PHP_FLOAT_MAX;
+        $minDiffUp   = PHP_FLOAT_MAX;
+
+        foreach ($supports as $s) {
+            if ($s['price'] <= $price) {
+                $d = $price - $s['price'];
+                if ($d < $minDiffDown) {
+                    $minDiffDown = $d;
+                    $nearestSupport = $s;
+                }
+            }
+        }
+        foreach ($resistances as $r) {
+            if ($r['price'] >= $price) {
+                $d = $r['price'] - $price;
+                if ($d < $minDiffUp) {
+                    $minDiffUp = $d;
+                    $nearestResistance = $r;
+                }
+            }
+        }
+
+        return ['nearest_support' => $nearestSupport, 'nearest_resistance' => $nearestResistance];
+    }
+
+    /**
+     * Ajuste un SL basé sur un support (long) avec un buffer ATR.
+     * $atrPct = ATR/price (ex: 0.012 = 1.2%); $k = multiplicateur (ex: 1.0).
+     * Règle: SL% = max(distance_support, k*atrPct). Retourne le prix du SL.
+     */
+    public function stopFromSupportWithATR(float $entry, float $support, float $atrPct, float $k = 1.0): float
+    {
+        $distSRPct = max(0.0, ($entry - $support) / $entry);
+        $finalPct  = max($distSRPct, $k * $atrPct);
+        return $entry * (1.0 - $finalPct);
+    }
+
+    /**
+     * Variante pour un short: SL au-dessus de la résistance avec buffer ATR.
+     */
+    public function stopFromResistanceWithATR(float $entry, float $resistance, float $atrPct, float $k = 1.0): float
+    {
+        $distSRPct = max(0.0, ($resistance - $entry) / $entry);
+        $finalPct  = max($distSRPct, $k * $atrPct);
+        return $entry * (1.0 + $finalPct);
+    }
+}
Index: symfony-app/src/Entity/Position.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\nnamespace App\\Entity;\n\nuse App\\Repository\\PositionRepository;\nuse Doctrine\\ORM\\Mapping as ORM;\n\n#[ORM\\Entity(repositoryClass: PositionRepository::class)]\n#[ORM\\Table(name: 'positions')]\n#[ORM\\HasLifecycleCallbacks]\nclass Position\n{\n    public const SIDE_LONG  = 'LONG';\n    public const SIDE_SHORT = 'SHORT';\n\n    public const STATUS_PENDING   = 'PENDING';\n    public const STATUS_OPEN      = 'OPEN';\n    public const STATUS_CLOSED    = 'CLOSED';\n    public const STATUS_CANCELLED = 'CANCELLED';\n\n    public const STATUS_EXPIRED    = 'EXPIRED';   //  TTL interne atteint\n    public const STATUS_REJECTED   = 'REJECTED';  //  refusée par exchange\n\n    // TIF (durée de vie côté exchange)\n    public const TIF_GTC = 'GTC'; // Good-Till-Cancel\n    public const TIF_IOC = 'IOC';\n    public const TIF_FOK = 'FOK';\n\n\n    #[ORM\\Id]\n    #[ORM\\GeneratedValue]\n    #[ORM\\Column(type: 'bigint')]\n    private ?int $id = null;\n\n    /**\n     * FK vers Contract(symbol) — Contract a une PK string 'symbol'\n     */\n    #[ORM\\ManyToOne(targetEntity: Contract::class)]\n    #[ORM\\JoinColumn(\n        name: 'contract_symbol',\n        referencedColumnName: 'symbol',\n        nullable: false,\n        onDelete: 'CASCADE'\n    )]\n    private Contract $contract;\n\n    #[ORM\\Column(length: 32)]\n    private string $exchange = 'bitmart';\n\n    #[ORM\\Column(length: 5)]\n    private string $side = self::SIDE_LONG;\n\n    #[ORM\\Column(length: 16)]\n    private string $status = self::STATUS_PENDING;\n\n    // Montant notionnel en USDT (ex: 100)\n    #[ORM\\Column(type: 'decimal', precision: 18, scale: 8)]\n    private string $amountUsdt = '0';\n\n    // Prix d'entrée et quantité (en contrats), si connus au moment de l'ouverture\n    #[ORM\\Column(type: 'decimal', precision: 18, scale: 8, nullable: true)]\n    private ?string $entryPrice = null;\n\n    #[ORM\\Column(type: 'decimal', precision: 28, scale: 12, nullable: true)]\n    private ?string $qtyContract = null;\n\n    // Effet de levier (facultatif)\n    #[ORM\\Column(type: 'decimal', precision: 6, scale: 2, nullable: true)]\n    private ?string $leverage = null;\n\n    // Référence d’ordre côté exchange (si tu intègres un jour l’API de trading)\n    #[ORM\\Column(length: 128, nullable: true)]\n    private ?string $externalOrderId = null;\n\n    // Timestamps métier\n    #[ORM\\Column(type: 'datetime_immutable', nullable: true)]\n    private ?\\DateTimeImmutable $openedAt = null;\n\n    #[ORM\\Column(type: 'datetime_immutable', nullable: true)]\n    private ?\\DateTimeImmutable $closedAt = null;\n\n    // Gestion du risque\n    #[ORM\\Column(type: 'decimal', precision: 18, scale: 8, nullable: true)]\n    private ?string $stopLoss = null;\n\n    #[ORM\\Column(type: 'decimal', precision: 18, scale: 8, nullable: true)]\n    private ?string $takeProfit = null;\n\n    // PnL réalisé en USDT (à la clôture)\n    #[ORM\\Column(type: 'decimal', precision: 18, scale: 8, nullable: true)]\n    private ?string $pnlUsdt = null;\n\n    // Espace libre pour stocker la décision / scores indicateurs / debug\n    #[ORM\\Column(type: 'json', nullable: true)]\n    private ?array $meta = null;\n\n    // Audit\n    #[ORM\\Column(type: 'datetime_immutable')]\n    private \\DateTimeImmutable $createdAt;\n\n    #[ORM\\Column(type: 'datetime_immutable')]\n    private \\DateTimeImmutable $updatedAt;\n\n    #[ORM\\PreUpdate]\n    public function onPreUpdate(): void\n    {\n        $this->updatedAt = new \\DateTimeImmutable();\n    }\n\n    // ------------ Getters / Setters ------------\n\n    public function getId(): ?int { return $this->id; }\n\n    public function getContract(): Contract { return $this->contract; }\n    public function setContract(Contract $contract): self { $this->contract = $contract; return $this; }\n\n    public function getExchange(): string { return $this->exchange; }\n    public function setExchange(string $exchange): self { $this->exchange = $exchange; return $this; }\n\n    public function getSide(): string { return $this->side; }\n    public function setSide(string $side): self { $this->side = $side; return $this; }\n\n    public function getStatus(): string { return $this->status; }\n    public function setStatus(string $status): self { $this->status = $status; return $this; }\n\n    public function getAmountUsdt(): string { return $this->amountUsdt; }\n    public function setAmountUsdt(string $amountUsdt): self { $this->amountUsdt = $amountUsdt; return $this; }\n\n    public function getEntryPrice(): ?string { return $this->entryPrice; }\n    public function setEntryPrice(?string $entryPrice): self { $this->entryPrice = $entryPrice; return $this; }\n\n    public function getQtyContract(): ?string { return $this->qtyContract; }\n    public function setQtyContract(?string $qtyContract): self { $this->qtyContract = $qtyContract; return $this; }\n\n    public function getLeverage(): ?string { return $this->leverage; }\n    public function setLeverage(?string $leverage): self { $this->leverage = $leverage; return $this; }\n\n    public function getExternalOrderId(): ?string { return $this->externalOrderId; }\n    public function setExternalOrderId(?string $externalOrderId): self { $this->externalOrderId = $externalOrderId; return $this; }\n\n    public function getOpenedAt(): ?\\DateTimeImmutable { return $this->openedAt; }\n    public function setOpenedAt(?\\DateTimeImmutable $openedAt): self { $this->openedAt = $openedAt; return $this; }\n\n    public function getClosedAt(): ?\\DateTimeImmutable { return $this->closedAt; }\n    public function setClosedAt(?\\DateTimeImmutable $closedAt): self { $this->closedAt = $closedAt; return $this; }\n\n    public function getStopLoss(): ?string { return $this->stopLoss; }\n    public function setStopLoss(?string $stopLoss): self { $this->stopLoss = $stopLoss; return $this; }\n\n    public function getTakeProfit(): ?string { return $this->takeProfit; }\n    public function setTakeProfit(?string $takeProfit): self { $this->takeProfit = $takeProfit; return $this; }\n\n    public function getPnlUsdt(): ?string { return $this->pnlUsdt; }\n    public function setPnlUsdt(?string $pnlUsdt): self { $this->pnlUsdt = $pnlUsdt; return $this; }\n\n    public function getMeta(): ?array { return $this->meta; }\n    public function setMeta(?array $meta): self { $this->meta = $meta; return $this; }\n\n    public function getCreatedAt(): \\DateTimeImmutable { return $this->createdAt; }\n    public function setCreatedAt(\\DateTimeImmutable $createdAt): self { $this->createdAt = $createdAt; return $this; }\n\n    public function getUpdatedAt(): \\DateTimeImmutable { return $this->updatedAt; }\n    public function setUpdatedAt(\\DateTimeImmutable $updatedAt): self { $this->updatedAt = $updatedAt; return $this; }\n\n    #[ORM\\Column(length: 8, options: ['default' => self::TIF_GTC])]\n    private string $timeInForce = self::TIF_GTC;  // ✅ reflète la durée côté exchange\n\n    #[ORM\\Column(type: 'datetime_immutable', nullable: true)]\n    private ?\\DateTimeImmutable $expiresAt = null; // ✅ TTL interne (ex: created+2min si PENDING)\n\n    #[ORM\\Column(length: 32, nullable: true)]\n    private ?string $externalStatus = null; // ✅ NEW/OPEN/CANCELED/REJECTED (copie exchange)\n\n    #[ORM\\Column(type: 'datetime_immutable', nullable: true)]\n    private ?\\DateTimeImmutable $lastSyncAt = null; // ✅ dernière synchro avec l’API\n\n    // --- lifecycle: initialise created/updated, et TTL par défaut si PENDING ---\n    #[ORM\\PrePersist]\n    public function onPrePersist(): void\n    {\n        $now = new \\DateTimeImmutable();\n        $this->createdAt = $now;\n        $this->updatedAt = $now;\n\n        // TTL soft par défaut : par ex. 2 minutes pour les PENDING sans ordre exchange\n        if ($this->status === self::STATUS_PENDING && $this->expiresAt === null) {\n            $this->expiresAt = $now->modify('+2 minutes'); // ajuste selon ta politique\n        }\n    }\n\n    // --- getters/setters additionnels ---\n    public function getTimeInForce(): string { return $this->timeInForce; }\n    public function setTimeInForce(string $tif): self { $this->timeInForce = $tif; return $this; }\n\n    public function getExpiresAt(): ?\\DateTimeImmutable { return $this->expiresAt; }\n    public function setExpiresAt(?\\DateTimeImmutable $dt): self { $this->expiresAt = $dt; return $this; }\n\n    public function getExternalStatus(): ?string { return $this->externalStatus; }\n    public function setExternalStatus(?string $s): self { $this->externalStatus = $s; return $this; }\n\n    public function getLastSyncAt(): ?\\DateTimeImmutable { return $this->lastSyncAt; }\n    public function setLastSyncAt(?\\DateTimeImmutable $dt): self { $this->lastSyncAt = $dt; return $this; }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Entity/Position.php b/symfony-app/src/Entity/Position.php
--- a/symfony-app/src/Entity/Position.php	(revision acfe8edc4f51e920bc6e35643a19748aa79bb144)
+++ b/symfony-app/src/Entity/Position.php	(date 1759584671947)
@@ -3,6 +3,8 @@
 namespace App\Entity;
 
 use App\Repository\PositionRepository;
+use Doctrine\Common\Collections\ArrayCollection;
+use Doctrine\Common\Collections\Collection;
 use Doctrine\ORM\Mapping as ORM;
 
 #[ORM\Entity(repositoryClass: PositionRepository::class)]
@@ -174,6 +176,26 @@
     #[ORM\Column(type: 'datetime_immutable', nullable: true)]
     private ?\DateTimeImmutable $lastSyncAt = null; // ✅ dernière synchro avec l’API
 
+    /** TPs liés à cet ordre (position) */
+    #[ORM\ManyToMany(targetEntity: self::class)]
+    #[ORM\JoinTable(name: 'orders_take_profits')]
+    #[ORM\JoinColumn(name: 'parent_order_id', referencedColumnName: 'id', onDelete: 'CASCADE')]
+    #[ORM\InverseJoinColumn(name: 'child_order_id', referencedColumnName: 'id', onDelete: 'CASCADE')]
+    private Collection $ordersTakeProfit;
+
+    /** SLs liés à cet ordre (position) */
+    #[ORM\ManyToMany(targetEntity: self::class)]
+    #[ORM\JoinTable(name: 'orders_stop_losses')]
+    #[ORM\JoinColumn(name: 'parent_order_id', referencedColumnName: 'id', onDelete: 'CASCADE')]
+    #[ORM\InverseJoinColumn(name: 'child_order_id', referencedColumnName: 'id', onDelete: 'CASCADE')]
+    private Collection $ordersStopLoss;
+
+    public function __construct()
+    {
+        $this->ordersTakeProfit = new ArrayCollection();
+        $this->ordersStopLoss   = new ArrayCollection();
+    }
+
     // --- lifecycle: initialise created/updated, et TTL par défaut si PENDING ---
     #[ORM\PrePersist]
     public function onPrePersist(): void
@@ -200,5 +222,35 @@
 
     public function getLastSyncAt(): ?\DateTimeImmutable { return $this->lastSyncAt; }
     public function setLastSyncAt(?\DateTimeImmutable $dt): self { $this->lastSyncAt = $dt; return $this; }
+    public function addTakeProfit(Order $tp): void
+    {
+        if (!$this->ordersTakeProfit->contains($tp)) {
+            $this->ordersTakeProfit->add($tp);
+        }
+    }
+    public function removeTakeProfit(Order $tp): void
+    {
+        $this->ordersTakeProfit->removeElement($tp);
+    }
+    public function getOrdersTakeProfit(): Collection
+    {
+        return $this->ordersTakeProfit;
+    }
+
+    // --- helpers (SL) ---
+    public function addStopLoss(Order $sl): void
+    {
+        if (!$this->ordersStopLoss->contains($sl)) {
+            $this->ordersStopLoss->add($sl);
+        }
+    }
+    public function removeStopLoss(Order $sl): void
+    {
+        $this->ordersStopLoss->removeElement($sl);
+    }
+    public function getOrdersStopLoss(): Collection
+    {
+        return $this->ordersStopLoss;
+    }
 }
 
Index: symfony-app/src/Service/Exchange/Bitmart/Dto/SubmitOrderResponseDto.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Service/Exchange/Bitmart/Dto/SubmitOrderResponseDto.php b/symfony-app/src/Service/Exchange/Bitmart/Dto/SubmitOrderResponseDto.php
new file mode 100644
--- /dev/null	(date 1759488433000)
+++ b/symfony-app/src/Service/Exchange/Bitmart/Dto/SubmitOrderResponseDto.php	(date 1759488433000)
@@ -0,0 +1,21 @@
+<?php
+
+namespace App\Service\Exchange\Bitmart\Dto;
+
+class SubmitOrderResponseDto
+{
+    public function __construct(
+        public readonly string $orderId,
+        public readonly ?int   $serverTimeMs = null
+    ) {}
+
+    public static function fromArray(array $a): self
+    {
+        // ex: ['code'=>1000,'message'=>'Ok','data'=>['order_id'=>'...'], 'trace'=>...]
+        $data = $a['data'] ?? [];
+        return new self(
+            orderId: (string)($data['order_id'] ?? $data['orderId'] ?? ''),
+            serverTimeMs: isset($a['timestamp']) ? (int)$a['timestamp'] : null
+        );
+    }
+}
Index: symfony-app/src/Service/Exchange/Bitmart/Dto/RestTradeDto.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Service/Exchange/Bitmart/Dto/RestTradeDto.php b/symfony-app/src/Service/Exchange/Bitmart/Dto/RestTradeDto.php
new file mode 100644
--- /dev/null	(date 1759488457000)
+++ b/symfony-app/src/Service/Exchange/Bitmart/Dto/RestTradeDto.php	(date 1759488457000)
@@ -0,0 +1,31 @@
+<?php
+
+namespace App\Service\Exchange\Bitmart\Dto;
+
+class RestTradeDto
+{
+    public function __construct(
+        public readonly string $tradeId,
+        public readonly string $orderId,
+        public readonly string $symbol,
+        public readonly string $fillQty,
+        public readonly string $fillPrice,
+        public readonly ?string $fee,
+        public readonly ?string $feeCcy,
+        public readonly ?int    $serverTimeMs
+    ) {}
+
+    public static function fromArray(array $a): self
+    {
+        return new self(
+            tradeId:  (string)($a['trade_id'] ?? $a['id'] ?? ''),
+            orderId:  (string)($a['order_id'] ?? ''),
+            symbol:   (string)$a['symbol'],
+            fillQty:  (string)($a['size'] ?? $a['qty'] ?? '0'),
+            fillPrice:(string)($a['price'] ?? '0'),
+            fee:      isset($a['fee']) ? (string)$a['fee'] : null,
+            feeCcy:   isset($a['fee_ccy']) ? (string)$a['fee_ccy'] : null,
+            serverTimeMs: isset($a['ms_t']) ? (int)$a['ms_t'] : (isset($a['timestamp'])?(int)$a['timestamp']:null)
+        );
+    }
+}
Index: symfony-app/src/Service/Exchange/Bitmart/Dto/WsOrderEventDto.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Service/Exchange/Bitmart/Dto/WsOrderEventDto.php b/symfony-app/src/Service/Exchange/Bitmart/Dto/WsOrderEventDto.php
new file mode 100644
--- /dev/null	(date 1759488480000)
+++ b/symfony-app/src/Service/Exchange/Bitmart/Dto/WsOrderEventDto.php	(date 1759488480000)
@@ -0,0 +1,54 @@
+<?php
+
+namespace App\Service\Exchange\Bitmart\Dto;
+
+class WsOrderEventDto
+{
+    public function __construct(
+        public readonly int     $action,     // 1=match,2=submit,3=cancel, etc.
+        public readonly ?int    $stateRaw,   // 1/2/4
+        public readonly ?string $orderId,
+        public readonly ?string $clientOrderId,
+        public readonly string  $symbol,
+        public readonly ?string $dealSize,       // cumul total
+        public readonly ?string $dealAvgPrice,
+        public readonly ?string $lastTradeId,
+        public readonly ?string $lastFillQty,
+        public readonly ?string $lastFillPrice,
+        public readonly ?string $lastFee,
+        public readonly ?string $lastFeeCcy,
+        // conditionnels
+        public readonly ?string $planOrderId,
+        public readonly ?string $triggerPrice,
+        public readonly ?string $executionPrice,
+        public readonly ?string $activationPrice,
+        public readonly ?string $callbackRate,
+        public readonly ?int    $serverUpdateTimeMs
+    ) {}
+
+    public static function fromArray(array $a): self
+    {
+        $order = $a['order'] ?? $a; // selon enveloppe
+        $last  = $order['last_trade'] ?? [];
+        return new self(
+            action:       (int)($a['action'] ?? $order['action'] ?? 0),
+            stateRaw:     isset($order['state']) ? (int)$order['state'] : null,
+            orderId:      isset($order['order_id']) ? (string)$order['order_id'] : null,
+            clientOrderId:isset($order['client_order_id']) ? (string)$order['client_order_id'] : null,
+            symbol:       (string)($order['symbol'] ?? $a['symbol'] ?? ''),
+            dealSize:     isset($order['deal_size']) ? (string)$order['deal_size'] : null,
+            dealAvgPrice: isset($order['deal_avg_price']) ? (string)$order['deal_avg_price'] : null,
+            lastTradeId:  isset($last['lastTradeID']) ? (string)$last['lastTradeID'] : null,
+            lastFillQty:  isset($last['fillQty']) ? (string)$last['fillQty'] : null,
+            lastFillPrice:isset($last['fillPrice']) ? (string)$last['fillPrice'] : null,
+            lastFee:      isset($last['fee']) ? (string)$last['fee'] : null,
+            lastFeeCcy:   isset($last['feeCcy']) ? (string)$last['feeCcy'] : null,
+            planOrderId:  isset($order['plan_order_id']) ? (string)$order['plan_order_id'] : null,
+            triggerPrice: isset($order['trigger_price']) ? (string)$order['trigger_price'] : null,
+            executionPrice:isset($order['execution_price']) ? (string)$order['execution_price'] : null,
+            activationPrice:isset($order['activation_price']) ? (string)$order['activation_price'] : null,
+            callbackRate: isset($order['callback_rate']) ? (string)$order['callback_rate'] : null,
+            serverUpdateTimeMs: isset($order['update_time']) ? (int)$order['update_time'] : (isset($a['ts'])?(int)$a['ts']:null),
+        );
+    }
+}
Index: symfony-app/src/Service/Exchange/Bitmart/Dto/RestOrderDetailDto.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Service/Exchange/Bitmart/Dto/RestOrderDetailDto.php b/symfony-app/src/Service/Exchange/Bitmart/Dto/RestOrderDetailDto.php
new file mode 100644
--- /dev/null	(date 1759488391000)
+++ b/symfony-app/src/Service/Exchange/Bitmart/Dto/RestOrderDetailDto.php	(date 1759488391000)
@@ -0,0 +1,39 @@
+<?php
+
+namespace App\Service\Exchange\Bitmart\Dto;
+
+class RestOrderDetailDto
+{
+    public function __construct(
+        public readonly ?string $orderId,
+        public readonly string  $clientOrderId,
+        public readonly string  $symbol,
+        public readonly string  $type,             // "limit"/"market"/"plan_order"/...
+        public readonly ?string $price,
+        public readonly string  $size,
+        public readonly string  $dealSize,         // cumul
+        public readonly ?string $dealAvgPrice,
+        public readonly ?string $feesCum,
+        public readonly ?string $statusText,       // "open","filled","canceled"... (si dispo)
+        public readonly ?int    $stateRaw,         // 1/2/4 si dispo
+        public readonly ?int    $serverUpdateTimeMs
+    ) {}
+
+    public static function fromArray(array $a): self
+    {
+        return new self(
+            orderId:      isset($a['order_id']) ? (string)$a['order_id'] : (isset($a['orderId'])?(string)$a['orderId']:null),
+            clientOrderId:(string)($a['client_order_id'] ?? $a['clientOrderId'] ?? ''),
+            symbol:       (string)$a['symbol'],
+            type:         (string)$a['type'],
+            price:        isset($a['price']) ? (string)$a['price'] : null,
+            size:         (string)($a['size'] ?? '0'),
+            dealSize:     (string)($a['deal_size'] ?? $a['filled_size'] ?? '0'),
+            dealAvgPrice: isset($a['deal_avg_price']) ? (string)$a['deal_avg_price'] : null,
+            feesCum:      isset($a['fees']) ? (string)$a['fees'] : null,
+            statusText:   isset($a['status']) ? (string)$a['status'] : ($a['state_text'] ?? null),
+            stateRaw:     isset($a['state']) ? (int)$a['state'] : null,
+            serverUpdateTimeMs: isset($a['update_time']) ? (int)$a['update_time'] : (isset($a['ms'])?(int)$a['ms']:null)
+        );
+    }
+}
Index: symfony-app/src/Service/Exchange/Bitmart/Dto/SubmitOrderRequestDto.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Service/Exchange/Bitmart/Dto/SubmitOrderRequestDto.php b/symfony-app/src/Service/Exchange/Bitmart/Dto/SubmitOrderRequestDto.php
new file mode 100644
--- /dev/null	(date 1759488422000)
+++ b/symfony-app/src/Service/Exchange/Bitmart/Dto/SubmitOrderRequestDto.php	(date 1759488422000)
@@ -0,0 +1,49 @@
+<?php
+
+namespace App\Service\Exchange\Bitmart\Dto;
+
+class SubmitOrderRequestDto
+{
+    public function __construct(
+        public readonly string $symbol,
+        public readonly string $clientOrderId,
+        public readonly int    $side,
+        public readonly int    $mode,
+        public readonly string $type,                 // "limit" | "market" | "plan_order" | "trailing"...
+        public readonly string $size,                 // décimal en string
+        public readonly ?string $price = null,        // requis si limit
+        public readonly ?int    $leverage = null,
+        public readonly ?string $openType = null,     // "isolated" | "cross"
+        // champs optionnels (tp/sl/plan/trailing)
+        public readonly ?string $triggerPrice = null,
+        public readonly ?string $executionPrice = null,
+        public readonly ?string $activationPrice = null,
+        public readonly ?string $callbackRate = null,
+    ) {
+        if ($this->symbol === '' || $this->clientOrderId === '') {
+            throw new \InvalidArgumentException('symbol et clientOrderId sont requis');
+        }
+        if ($this->type === 'limit' && ($this->price === null || (float)$this->price <= 0)) {
+            throw new \InvalidArgumentException('price requis (>0) pour un ordre limit');
+        }
+    }
+
+    public static function fromArray(array $a): self
+    {
+        return new self(
+            symbol:         (string)$a['symbol'],
+            clientOrderId:  (string)$a['client_order_id'],
+            side:           (int)$a['side'],
+            mode:           (int)$a['mode'],
+            type:           (string)$a['type'],
+            size:           (string)$a['size'],
+            price:          isset($a['price']) ? (string)$a['price'] : null,
+            leverage:       isset($a['leverage']) ? (int)$a['leverage'] : null,
+            openType:       $a['open_type'] ?? null,
+            triggerPrice:   $a['trigger_price']   ?? null,
+            executionPrice: $a['execution_price'] ?? null,
+            activationPrice:$a['activation_price']?? null,
+            callbackRate:   $a['callback_rate']   ?? null,
+        );
+    }
+}
Index: symfony-app/src/Repository/OrderRepository.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Repository/OrderRepository.php b/symfony-app/src/Repository/OrderRepository.php
new file mode 100644
--- /dev/null	(date 1759486825000)
+++ b/symfony-app/src/Repository/OrderRepository.php	(date 1759486825000)
@@ -0,0 +1,16 @@
+<?php
+declare(strict_types=1);
+
+namespace App\Repository;
+
+use App\Entity\Order;
+use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
+use Doctrine\Persistence\ManagerRegistry;
+
+final class OrderRepository extends ServiceEntityRepository
+{
+    public function __construct(ManagerRegistry $registry)
+    {
+        parent::__construct($registry, Order::class);
+    }
+}
Index: symfony-app/src/Service/Trading/OrderHydrator.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Service/Trading/OrderHydrator.php b/symfony-app/src/Service/Trading/OrderHydrator.php
new file mode 100644
--- /dev/null	(date 1759586870480)
+++ b/symfony-app/src/Service/Trading/OrderHydrator.php	(date 1759586870480)
@@ -0,0 +1,227 @@
+<?php
+
+namespace App\Service\Trading;
+
+use App\Entity\Order;
+use App\Enum\OrderOpenType;
+use App\Enum\OrderType;
+use App\Enum\Side;
+use App\Service\Exchange\Bitmart\Dto\RestOrderDetailDto;
+use App\Service\Exchange\Bitmart\Dto\RestTradeDto;
+use App\Service\Exchange\Bitmart\Dto\SubmitOrderRequestDto;
+use App\Service\Exchange\Bitmart\Dto\SubmitOrderResponseDto;
+use App\Service\Exchange\Bitmart\Dto\WsOrderEventDto;
+
+class OrderHydrator
+{
+    /** Crée l’entité Order à partir d’un SubmitOrderRequestDto (+ infos métier locales) */
+    public static function createFromSubmitRequest(
+        SubmitOrderRequestDto $req,
+        string $contractPipelineId,
+        Side $side,
+        OrderType $type,
+        ?float $stopLossPrice = 0.0,
+        ?float $takeProfitPrice = 0.0,
+        int $leverage = 1,
+        OrderOpenType $openType = OrderOpenType::ISOLATED
+    ): Order {
+        return Order::createNew(
+            contractPipelineId: $contractPipelineId,
+            clientOrderId:      $req->clientOrderId,
+            symbol:             $req->symbol,
+            side:               $side,
+            type:               $type,
+            price:              $req->price,
+            size:               $req->size,
+            leverage:           $leverage ?: ($req->leverage ?? 1),
+            openType:           $openType,
+            stopLoss:      $stopLossPrice,
+            takeProfit:    $takeProfitPrice,
+        );
+    }
+
+    /** Applique la réponse REST submit → markSubmitted */
+    public static function onSubmitResponse(Order $order, SubmitOrderResponseDto $res): void
+    {
+        if ($res->orderId !== '') {
+            $order->markSubmitted($res->orderId, $res->serverTimeMs);
+        }
+    }
+
+    /** Merge d’un snapshot REST (open order/detail) → reconcileFromRestSnapshot */
+    public static function mergeRestOrderSnapshot(Order $order, RestOrderDetailDto $dto): void
+    {
+        $order->reconcileFromRestSnapshot(
+            exchangeOrderId:   $dto->orderId,
+            dealSize:          $dto->dealSize,
+            dealAvgPrice:      $dto->dealAvgPrice,
+            feesCum:           $dto->feesCum,
+            serverUpdateTimeMs:$dto->serverUpdateTimeMs,
+            stateRaw:          $dto->stateRaw,
+            statusHint:        $dto->statusText? strtoupper($dto->statusText) : null
+        );
+    }
+
+    /** Applique un fill REST (trade) */
+    public static function applyRestTrade(Order $order, RestTradeDto $t): void
+    {
+        $order->applyFill(
+            tradeId:           $t->tradeId,
+            fillQty:           $t->fillQty,
+            fillPrice:         $t->fillPrice,
+            fee:               $t->fee,
+            feeCcy:            $t->feeCcy,
+            stateRaw:          null,
+            serverUpdateTimeMs:$t->serverTimeMs
+        );
+    }
+
+    /** Applique un event WS order (submit | match | cancel | info conditionnelle) */
+    public static function applyWsOrderEvent(Order $order, WsOrderEventDto $e): void
+    {
+        switch ($e->action) {
+            case 2: // submit
+                $order->applyWsSubmitted($e->stateRaw, $e->serverUpdateTimeMs);
+                break;
+
+            case 1: // match (fill)
+                // last_trade présent → on s’appuie dessus
+                if ($e->lastTradeId && $e->lastFillQty && $e->lastFillPrice) {
+                    $order->applyFill(
+                        tradeId:           $e->lastTradeId,
+                        fillQty:           $e->lastFillQty,
+                        fillPrice:         $e->lastFillPrice,
+                        fee:               $e->lastFee,
+                        feeCcy:            $e->lastFeeCcy,
+                        stateRaw:          $e->stateRaw,
+                        serverUpdateTimeMs:$e->serverUpdateTimeMs
+                    );
+                } else {
+                    // Pas de détail du dernier trade → au minimum, on réconcilie les cumuls
+                    $order->reconcileFromRestSnapshot(
+                        exchangeOrderId:   $e->orderId,
+                        dealSize:          $e->dealSize,
+                        dealAvgPrice:      $e->dealAvgPrice,
+                        feesCum:           null,
+                        serverUpdateTimeMs:$e->serverUpdateTimeMs,
+                        stateRaw:          $e->stateRaw,
+                        statusHint:        null
+                    );
+                }
+                break;
+
+            case 3: // cancel
+                $order->cancel(
+                    reason:             'Cancelled via WS',
+                    serverUpdateTimeMs: $e->serverUpdateTimeMs,
+                    stateRaw:           $e->stateRaw
+                );
+                break;
+
+            default:
+                // Attacher/mettre à jour les infos conditionnelles si présentes
+                if ($e->planOrderId || $e->triggerPrice || $e->executionPrice || $e->activationPrice || $e->callbackRate) {
+                    $order->attachConditional(
+                        planOrderId:       $e->planOrderId,
+                        triggerPrice:      $e->triggerPrice,
+                        executionPrice:    $e->executionPrice,
+                        activationPrice:   $e->activationPrice,
+                        callbackRate:      $e->callbackRate,
+                        serverUpdateTimeMs:$e->serverUpdateTimeMs
+                    );
+                }
+            // pas de transition de statut si action non gérée
+        }
+    }
+
+    /**
+     * A utiliser quand le submit REST ne renvoie pas d'order_id ou renvoie un code d'erreur.
+     * - Si c'est une erreur "métier/API" (ex: invalid params, insufficient margin) => REJECTED
+     * - Si c'est une erreur "technique/IO" (timeout, 5xx, réseau) => FAILED
+     */
+    public static function onSubmitFailure(
+        Order   $order,
+        string  $errorMessage,
+        ?int    $serverTimeMs = null,
+        ?int    $httpStatus   = null,
+        ?int    $exchangeCode = null     // ex: code Bitmart si dispo
+    ): void {
+        $isBusiness = self::isBusinessError($httpStatus, $exchangeCode, $errorMessage);
+
+        if ($isBusiness) {
+            $order->reject(
+                reason: sprintf('[REJECTED] %s (http=%s code=%s)', $errorMessage, (string)$httpStatus, (string)$exchangeCode),
+                serverUpdateTimeMs: $serverTimeMs
+            );
+        } else {
+            $order->fail(
+                reason: sprintf('[FAILED] %s (http=%s code=%s)', $errorMessage, (string)$httpStatus, (string)$exchangeCode),
+                serverUpdateTimeMs: $serverTimeMs
+            );
+        }
+    }
+
+    /**
+     * Heuristique : distingue erreur "métier/API" vs "technique".
+     * - HTTP 4xx → REJECTED (métier)
+     * - HTTP 5xx/0 → FAILED (technique)
+     * - Codes d’API connus : ex. margin insuffisante, param invalide → REJECTED
+     */
+    private static function isBusinessError(?int $httpStatus, ?int $exchangeCode, string $message): bool
+    {
+        // 1) HTTP status
+        if ($httpStatus !== null) {
+            if ($httpStatus >= 400 && $httpStatus < 500) {
+                return true; // client error => rejet
+            }
+            if ($httpStatus >= 500 || $httpStatus === 0) {
+                return false; // serveur/IO => failed
+            }
+        }
+
+        // 2) Code d'exchange (si tu connais les mappings précis Bitmart, affine ici)
+        // Exemple : codes génériques (à adapter selon ta lib/API)
+        $businessCodes = [
+            // Paramètres invalides, quantité/price hors pas, pas de solde/marge, position mode incompatible…
+            10020, 10021, 33001, 33002, 33007, 30004, 30005, 30006, 30012, 30026,
+        ];
+        if ($exchangeCode !== null && in_array($exchangeCode, $businessCodes, true)) {
+            return true;
+        }
+
+        // 3) Heuristique sur le message
+        $msg = mb_strtolower($message);
+        $businessHints = ['insufficient', 'margin', 'leverage', 'min', 'max', 'invalid', 'reduce only', 'notional', 'tick', 'step', 'position mode'];
+        foreach ($businessHints as $h) {
+            if (str_contains($msg, $h)) {
+                return true;
+            }
+        }
+
+        // par défaut : on considère technique
+        return false;
+    }
+
+    /**
+     * Variante pratique si tu attrapes directement une exception (client HTTP).
+     * Tente de deviner REJECTED vs FAILED selon le type/status/code présent dans l'exception.
+     */
+    public static function onSubmitException(Order $order, Throwable $e, ?int $serverTimeMs = null): void
+    {
+        // Essaie d'extraire des infos (si tu utilises Symfony HttpClient/Guzzle, adapte ici)
+        $httpStatus   = method_exists($e, 'getCode') ? (int)$e->getCode() : null;
+        $exchangeCode = null;
+
+        // Si ton client conserve la réponse JSON de Bitmart dans l'exception, pars-la ici et remplis $exchangeCode.
+        // ex: if ($e instanceof BitmartApiException) { $exchangeCode = $e->getExchangeCode(); }
+
+        self::onSubmitFailure(
+            order:        $order,
+            errorMessage: $e->getMessage(),
+            serverTimeMs: $serverTimeMs,
+            httpStatus:   $httpStatus,
+            exchangeCode: $exchangeCode
+        );
+    }
+
+}
Index: symfony-app/src/Enum/OrderType.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Enum/OrderType.php b/symfony-app/src/Enum/OrderType.php
new file mode 100644
--- /dev/null	(date 1759486405000)
+++ b/symfony-app/src/Enum/OrderType.php	(date 1759486405000)
@@ -0,0 +1,13 @@
+<?php
+
+namespace App\Enum;
+
+enum OrderType: string
+{
+    case LIMIT         = 'LIMIT';
+    case MARKET        = 'MARKET';
+    case STOP_LOSS     = 'STOP_LOSS';     // plan/stop
+    case TAKE_PROFIT   = 'TAKE_PROFIT';   // plan/tp
+    case PLAN_ORDER    = 'PLAN_ORDER';    // ordre conditionnel
+    case TRAILING      = 'TRAILING';      // trailing order
+}
Index: symfony-app/src/Enum/OrderOpenType.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Enum/OrderOpenType.php b/symfony-app/src/Enum/OrderOpenType.php
new file mode 100644
--- /dev/null	(date 1759486405000)
+++ b/symfony-app/src/Enum/OrderOpenType.php	(date 1759486405000)
@@ -0,0 +1,9 @@
+<?php
+
+namespace App\Enum;
+
+enum OrderOpenType: string
+{
+    case ISOLATED = 'isolated';
+    case CROSS    = 'cross';
+}
Index: symfony-app/src/Enum/OrderStatus.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Enum/OrderStatus.php b/symfony-app/src/Enum/OrderStatus.php
new file mode 100644
--- /dev/null	(date 1759486706000)
+++ b/symfony-app/src/Enum/OrderStatus.php	(date 1759486706000)
@@ -0,0 +1,15 @@
+<?php
+
+namespace App\Enum;
+
+enum OrderStatus: string
+{
+    case NEW              = 'NEW';              // créé localement (pas encore soumis)
+    case SUBMITTED        = 'SUBMITTED';        // accepté par l’exchange (order_id connu)
+    case PARTIALLY_FILLED = 'PARTIALLY_FILLED'; // exécution partielle
+    case FILLED           = 'FILLED';           // exécuté à 100 %
+    case CANCELLED        = 'CANCELLED';        // annulé explicitement
+    case EXPIRED          = 'EXPIRED';          // annulé par l’app (timeout) / TTL
+    case REJECTED         = 'REJECTED';         // refus API
+    case FAILED           = 'FAILED';           // erreur interne technique
+}
Index: symfony-app/src/Enum/Side.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Enum/Side.php b/symfony-app/src/Enum/Side.php
new file mode 100644
--- /dev/null	(date 1759486243000)
+++ b/symfony-app/src/Enum/Side.php	(date 1759486243000)
@@ -0,0 +1,9 @@
+<?php
+
+namespace App\Enum;
+
+enum Side: string
+{
+    case LONG  = 'LONG';
+    case SHORT = 'SHORT';
+}
Index: symfony-app/src/Entity/Order.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/symfony-app/src/Entity/Order.php b/symfony-app/src/Entity/Order.php
new file mode 100644
--- /dev/null	(date 1759585055977)
+++ b/symfony-app/src/Entity/Order.php	(date 1759585055977)
@@ -0,0 +1,678 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Entity;
+
+use App\Enum\OrderStatus;
+use App\Enum\OrderType;
+use App\Enum\Side;
+use App\Enum\OrderOpenType;
+
+use DateTimeImmutable;
+use Doctrine\ORM\Mapping as ORM;
+use DomainException;
+use InvalidArgumentException;
+
+
+/**
+ * Entité Order (agrégat) — aucune méthode de type "setter".
+ * Toute mutation passe par des méthodes métier explicites et gardées.
+ */
+#[ORM\Entity]
+#[ORM\Table(name: 'orders')]
+#[ORM\UniqueConstraint(name: 'uniq_client_order_id', columns: ['client_order_id'])]
+#[ORM\Index(name: 'idx_contract_pipeline', columns: ['contract_pipeline_id'])]
+#[ORM\Index(name: 'idx_symbol', columns: ['symbol'])]
+#[ORM\Index(name: 'idx_status', columns: ['status'])]
+class Order
+{
+
+// ====== Champs persistés ======
+    #[ORM\Id]
+    #[ORM\GeneratedValue]
+    #[ORM\Column(type: 'bigint')]
+    private ?string $id = null;
+
+    #[ORM\Column(type: 'bigint')]
+    private string $contractPipelineId;
+
+    #[ORM\Column(type: 'string', length: 64, nullable: true)]
+    private ?string $exchangeOrderId = null; // order_id côté exchange
+
+    #[ORM\Column(type: 'string', length: 64)]
+    private string $clientOrderId; // idempotence interne (UNIQUE)
+
+    #[ORM\Column(type: 'string', length: 32)]
+    private string $symbol; // ex: BTCUSDT
+
+    #[ORM\Column(type: 'string', length: 8, enumType: Side::class)]
+    private Side $side;
+
+    #[ORM\Column(type: 'string', length: 16, enumType: OrderType::class)]
+    private OrderType $type;
+
+    #[ORM\Column(type: 'decimal', precision: 18, scale: 8, nullable: true)]
+    private ?string $price = null; // prix limite si LIMIT
+
+    #[ORM\Column(type: 'decimal', precision: 24, scale: 10)]
+    private string $size; // quantité demandée
+
+    #[ORM\Column(type: 'integer')]
+    private int $leverage = 1;
+
+    #[ORM\Column(type: 'string', length: 16, enumType: OrderOpenType::class)]
+    private OrderOpenType $openType = OrderOpenType::ISOLATED;
+
+    // ====== Champs plan/TP/SL/trailing (si applicable) ======
+    #[ORM\Column(type: 'string', length: 64, nullable: true)]
+    private ?string $planOrderId = null; // pour TP/SL/plan côté exchange
+
+    #[ORM\Column(type: 'decimal', precision: 18, scale: 8, nullable: true)]
+    private ?string $triggerPrice = null;
+
+    #[ORM\Column(type: 'decimal', precision: 18, scale: 8, nullable: true)]
+    private ?string $executionPrice = null;
+
+    #[ORM\Column(type: 'decimal', precision: 18, scale: 8, nullable: true)]
+    private ?string $activationPrice = null;
+
+    #[ORM\Column(type: 'decimal', precision: 10, scale: 6, nullable: true)]
+    private ?string $callbackRate = null; // trailing callback rate (%)
+
+    // ====== Statut & traces ======
+    #[ORM\Column(type: 'string', length: 24, enumType: OrderStatus::class)]
+    private OrderStatus $status = OrderStatus::NEW;
+
+    #[ORM\Column(type: 'string', length: 255, nullable: true)]
+    private ?string $reason = null; // texte explicatif (erreur/rejet)
+
+    #[ORM\Column(type: 'integer', nullable: true)]
+    private ?int $stateRaw = null; // state WS brut (1/2/4) si utile pour audit
+
+    // ====== Stats d’exécution cumulées (fills) ======
+    #[ORM\Column(type: 'decimal', precision: 24, scale: 10)]
+    private string $dealSize = '0'; // quantité exécutée cumulée
+
+    #[ORM\Column(type: 'decimal', precision: 18, scale: 8, nullable: true)]
+    private ?string $dealAvgPrice = null; // prix moyen d’exécution
+
+    #[ORM\Column(type: 'decimal', precision: 18, scale: 8)]
+    private string $feesCum = '0'; // cumul des fees
+
+    #[ORM\Column(type: 'string', length: 64, nullable: true)]
+    private ?string $lastTradeId = null;
+
+    #[ORM\Column(type: 'decimal', precision: 24, scale: 10, nullable: true)]
+    private ?string $lastFillQty = null;
+
+    #[ORM\Column(type: 'decimal', precision: 18, scale: 8, nullable: true)]
+    private ?string $lastFillPrice = null;
+
+    #[ORM\Column(type: 'decimal', precision: 18, scale: 8, nullable: true)]
+    private ?string $lastFee = null;
+
+    #[ORM\Column(type: 'string', length: 16, nullable: true)]
+    private ?string $lastFeeCcy = null;
+
+    // ====== Temps ======
+    #[ORM\Column(type: 'datetime_immutable')]
+    private DateTimeImmutable $createdAt;
+
+    #[ORM\Column(type: 'datetime_immutable', nullable: true)]
+    private ?DateTimeImmutable $openedAt = null;
+
+    #[ORM\Column(type: 'datetime_immutable', nullable: true)]
+    private ?DateTimeImmutable $filledAt = null;
+
+    #[ORM\Column(type: 'datetime_immutable', nullable: true)]
+    private ?DateTimeImmutable $closedAt = null;
+
+    #[ORM\Column(type: 'datetime_immutable')]
+    private DateTimeImmutable $updatedAt;
+
+    #[ORM\Column(type: 'bigint', nullable: true)]
+    private ?string $serverUpdateTimeMs = null;
+
+    #[ORM\Column(nullable: true)]
+    private ?float $stopLoss = null;
+
+    #[ORM\Column(nullable: true)]
+    private ?float $takeProfit = null; // timestamp serveur (WS/REST)
+
+    // ====== Constructeur privé ======
+    private function __construct(
+        string   $contractPipelineId,
+        string   $clientOrderId,
+        string   $symbol,
+        Side     $side,
+        OrderType     $type,
+        ?string  $price,
+        string   $size,
+        int      $leverage,
+        OrderOpenType $openType,
+        ?float $stopLoss = null,
+        ?float $takeProfit = null,
+    )
+    {
+        $this->contractPipelineId = $contractPipelineId;
+        $this->clientOrderId = $clientOrderId;
+        $this->symbol = $symbol;
+        $this->side = $side;
+        $this->type = $type;
+        $this->price = $price;
+        $this->size = $this->toDec($size);
+        $this->leverage = max(1, $leverage);
+        $this->openType = $openType;
+
+        $now = new DateTimeImmutable('now');
+        $this->createdAt = $now;
+        $this->updatedAt = $now;
+        $this->stopLoss = $stopLoss;
+        $this->takeProfit = $takeProfit;
+    }
+
+    // ====== Fabrique (création locale) ======
+    public static function createNew(
+        string   $contractPipelineId,
+        string   $clientOrderId,
+        string   $symbol,
+        Side     $side,
+        OrderType     $type,
+        ?string  $price,
+        string   $size,
+        int      $leverage = 1,
+        OrderOpenType $openType = OrderOpenType::ISOLATED,
+        ?float $stopLoss = null,
+        ?float $takeProfit = null
+    ): self
+    {
+        if ($clientOrderId === '') {
+            throw new InvalidArgumentException('client_order_id requis (idempotence).');
+        }
+        if ($size === '0' || bccomp($size, '0', 10) <= 0) {
+            throw new InvalidArgumentException('La taille (size) doit être > 0.');
+        }
+        if ($type === OrderType::LIMIT && ($price === null || bccomp($price, '0', 8) <= 0)) {
+            throw new InvalidArgumentException('Prix LIMIT obligatoire et > 0.');
+        }
+
+        return new self(
+            $contractPipelineId,
+            $clientOrderId,
+            $symbol,
+            $side,
+            $type,
+            $price,
+            $size,
+            $leverage,
+            $openType
+        );
+    }
+
+    // ====== Actions métier ======
+
+    /** Quand l’API REST renvoie un order_id après submit */
+    public function markSubmitted(string $exchangeOrderId, ?int $serverUpdateTimeMs = null): void
+    {
+        $this->guardTransition([OrderStatus::NEW, OrderStatus::SUBMITTED], 'markSubmitted');
+        $this->exchangeOrderId = $exchangeOrderId;
+        $this->status = OrderStatus::SUBMITTED;
+        $this->openedAt = $this->openedAt ?? new DateTimeImmutable('now');
+        $this->serverUpdateTimeMs = $serverUpdateTimeMs ?? $this->serverUpdateTimeMs;
+        $this->touch();
+    }
+
+    /** Quand le WS envoie un événement "submit" (action=2) */
+    public function applyWsSubmitted(?int $stateRaw, ?int $serverUpdateTimeMs): void
+    {
+        $this->guardTransition([OrderStatus::NEW, OrderStatus::SUBMITTED], 'applyWsSubmitted');
+        $this->stateRaw = $stateRaw;
+        $this->status = OrderStatus::SUBMITTED;
+        $this->openedAt = $this->openedAt ?? new DateTimeImmutable('now');
+        $this->serverUpdateTimeMs = $this->maxServerTs($serverUpdateTimeMs);
+        $this->touch();
+    }
+
+    /**
+     * Applique un trade (fill) du WS (action=1) ou d’un snapshot REST /trades
+     * Ajuste dealSize, dealAvgPrice, fees, lastTrade*, et détermine PARTIALLY_FILLED vs FILLED.
+     */
+    public function applyFill(
+        string  $tradeId,
+        string  $fillQty,
+        string  $fillPrice,
+        ?string $fee = null,
+        ?string $feeCcy = null,
+        ?int    $stateRaw = null,
+        ?int    $serverUpdateTimeMs = null
+    ): void
+    {
+        $this->guardTransition([
+            OrderStatus::SUBMITTED,
+            OrderStatus::PARTIALLY_FILLED
+        ], 'applyFill');
+
+        $fillQty = $this->toDec($fillQty);
+        $fillPrice = $this->toDec($fillPrice);
+        if (bccomp($fillQty, '0', 10) <= 0) {
+            return; // ignore fill nul
+        }
+
+        // cumul qty
+        $newDealSize = bcadd($this->dealSize, $fillQty, 10);
+
+        // prix moyen pondéré: (avg * old_qty + price * fillQty) / newDealSize
+        if (bccomp($newDealSize, '0', 10) > 0) {
+            $notionalOld = $this->dealAvgPrice ? bcmul($this->dealAvgPrice, $this->dealSize, 18) : '0';
+            $notionalNew = bcadd($notionalOld, bcmul($fillPrice, $fillQty, 18), 18);
+            $avg = bcdiv($notionalNew, $newDealSize, 8);
+            $this->dealAvgPrice = $avg;
+        }
+
+        $this->dealSize = $newDealSize;
+
+        // fees cum
+        if ($fee !== null) {
+            $this->feesCum = bcadd($this->feesCum, $this->toDec($fee), 8);
+        }
+
+        // trace dernier trade
+        $this->lastTradeId = $tradeId;
+        $this->lastFillQty = $fillQty;
+        $this->lastFillPrice = $fillPrice;
+        $this->lastFee = $fee;
+        $this->lastFeeCcy = $feeCcy;
+        $this->stateRaw = $stateRaw;
+
+        // statut
+        if ($this->isFullyFilled()) {
+            $this->status = OrderStatus::FILLED;
+            $this->filledAt = new DateTimeImmutable('now');
+            $this->closedAt = $this->closedAt ?? $this->filledAt;
+        } else {
+            $this->status = OrderStatus::PARTIALLY_FILLED;
+        }
+
+        $this->serverUpdateTimeMs = $this->maxServerTs($serverUpdateTimeMs);
+        $this->touch();
+    }
+
+    /** Annulation explicite (WS action=3, ou retour REST cancel OK) */
+    public function cancel(string $reason = 'Cancelled', ?int $serverUpdateTimeMs = null, ?int $stateRaw = null): void
+    {
+        $this->guardTransition([
+            OrderStatus::NEW,
+            OrderStatus::SUBMITTED,
+            OrderStatus::PARTIALLY_FILLED
+        ], 'cancel');
+
+        $this->status = OrderStatus::CANCELLED;
+        $this->reason = $reason;
+        $this->stateRaw = $stateRaw;
+        $this->closedAt = new DateTimeImmutable('now');
+        $this->serverUpdateTimeMs = $this->maxServerTs($serverUpdateTimeMs);
+        $this->touch();
+    }
+
+    /** Expiration (TTL/application) */
+    public function expire(string $reason = 'Expired by TTL', ?int $serverUpdateTimeMs = null): void
+    {
+        $this->guardTransition([
+            OrderStatus::NEW,
+            OrderStatus::SUBMITTED,
+            OrderStatus::PARTIALLY_FILLED
+        ], 'expire');
+
+        $this->status = OrderStatus::EXPIRED;
+        $this->reason = $reason;
+        $this->closedAt = new DateTimeImmutable('now');
+        $this->serverUpdateTimeMs = $this->maxServerTs($serverUpdateTimeMs);
+        $this->touch();
+    }
+
+    /** Rejet (échec submit) */
+    public function reject(string $reason, ?int $serverUpdateTimeMs = null): void
+    {
+        $this->guardTransition([OrderStatus::NEW, OrderStatus::SUBMITTED], 'reject');
+
+        $this->status = OrderStatus::REJECTED;
+        $this->reason = $reason;
+        $this->closedAt = new DateTimeImmutable('now');
+        $this->serverUpdateTimeMs = $this->maxServerTs($serverUpdateTimeMs);
+        $this->touch();
+    }
+
+    /** Failure interne (technique) */
+    public function fail(string $reason, ?int $serverUpdateTimeMs = null): void
+    {
+        $this->guardTransition([
+            OrderStatus::NEW,
+            OrderStatus::SUBMITTED,
+            OrderStatus::PARTIALLY_FILLED
+        ], 'fail');
+
+        $this->status = OrderStatus::FAILED;
+        $this->reason = $reason;
+        $this->closedAt = new DateTimeImmutable('now');
+        $this->serverUpdateTimeMs = $this->maxServerTs($serverUpdateTimeMs);
+        $this->touch();
+    }
+
+    /** Attache les infos d’ordres conditionnels (TP/SL/PLAN/TRAILING) */
+    public function attachConditional(
+        ?string $planOrderId,
+        ?string $triggerPrice,
+        ?string $executionPrice,
+        ?string $activationPrice,
+        ?string $callbackRate,
+        ?int    $serverUpdateTimeMs = null
+    ): void
+    {
+        $this->planOrderId = $planOrderId ?? $this->planOrderId;
+        $this->triggerPrice = $this->orDec($triggerPrice, $this->triggerPrice);
+        $this->executionPrice = $this->orDec($executionPrice, $this->executionPrice);
+        $this->activationPrice = $this->orDec($activationPrice, $this->activationPrice);
+        $this->callbackRate = $this->orDec($callbackRate, $this->callbackRate);
+        $this->serverUpdateTimeMs = $this->maxServerTs($serverUpdateTimeMs);
+        $this->touch();
+    }
+
+    /** Attache/merge un snapshot REST (open order/detail) pour conciliation */
+    public function reconcileFromRestSnapshot(
+        ?string $exchangeOrderId,
+        ?string $dealSize,
+        ?string $dealAvgPrice,
+        ?string $feesCum,
+        ?int    $serverUpdateTimeMs,
+        ?int    $stateRaw,
+        ?string $statusHint // 'FILLED','PARTIALLY_FILLED','CANCELLED', etc., si dispo
+    ): void
+    {
+        if ($exchangeOrderId && !$this->exchangeOrderId) {
+            $this->exchangeOrderId = $exchangeOrderId;
+        }
+        if ($dealSize !== null) {
+            $this->dealSize = $this->toDec($dealSize);
+        }
+        if ($dealAvgPrice !== null) {
+            $this->dealAvgPrice = $this->toDec($dealAvgPrice);
+        }
+        if ($feesCum !== null) {
+            $this->feesCum = $this->toDec($feesCum);
+        }
+        $this->stateRaw = $stateRaw ?? $this->stateRaw;
+
+        if ($statusHint) {
+            $mapped = self::mapExternalStatus($statusHint, $this->dealSize, $this->size);
+            if ($mapped !== null) {
+                $this->status = $mapped;
+                if ($this->status === OrderStatus::FILLED) {
+                    $this->filledAt = $this->filledAt ?? new DateTimeImmutable('now');
+                    $this->closedAt = $this->closedAt ?? $this->filledAt;
+                }
+            }
+        }
+
+        $this->serverUpdateTimeMs = $this->maxServerTs($serverUpdateTimeMs);
+        $this->touch();
+    }
+
+    // ====== Outils domaine ======
+
+    public function isFullyFilled(): bool
+    {
+        return bccomp($this->dealSize, $this->size, 10) === 0;
+    }
+
+    /** Mapping simple d’un statut externe texte → interne (optionnel, laisse null si inconnu) */
+    public static function mapExternalStatus(?string $external, string $dealSize, string $size): ?OrderStatus
+    {
+        if ($external === null) {
+            return null;
+        }
+        $external = strtoupper($external);
+        return match ($external) {
+            'NEW', 'SUBMITTED', 'OPEN' => OrderStatus::SUBMITTED,
+            'PARTIALLY_FILLED', 'PARTIAL' => (bccomp($dealSize, '0', 10) > 0 ? OrderStatus::PARTIALLY_FILLED : OrderStatus::SUBMITTED),
+            'FILLED', 'DONE' => OrderStatus::FILLED,
+            'CANCELLED', 'CANCELED' => OrderStatus::CANCELLED,
+            'EXPIRED' => OrderStatus::EXPIRED,
+            'REJECTED' => OrderStatus::REJECTED,
+            'FAILED', 'ERROR' => OrderStatus::FAILED,
+            default => null,
+        };
+    }
+
+    private function maxServerTs(?int $ts): ?string
+    {
+        if ($ts === null) {
+            return $this->serverUpdateTimeMs;
+        }
+        if ($this->serverUpdateTimeMs === null) {
+            return (string)$ts;
+        }
+        return ((int)$this->serverUpdateTimeMs >= $ts) ? $this->serverUpdateTimeMs : (string)$ts;
+    }
+
+    private function orDec(?string $v, ?string $fallback): ?string
+    {
+        return $v === null ? $fallback : $this->toDec($v);
+    }
+
+    private function toDec(string $v): string
+    {
+        // Normalise une valeur décimale en string (évite les flottants PHP)
+        if (!is_numeric($v)) {
+            throw new InvalidArgumentException("Valeur non numérique: $v");
+        }
+        return (string)$v;
+    }
+
+    private function guardTransition(array $allowedFrom, string $action): void
+    {
+        if (!in_array($this->status, $allowedFrom, true)) {
+            throw new DomainException(sprintf(
+                'Transition interdite: %s depuis %s',
+                $action,
+                $this->status->value
+            ));
+        }
+    }
+
+    private function touch(): void
+    {
+        $this->updatedAt = new DateTimeImmutable('now');
+    }
+
+    // ====== Getters (lecture seule publique) ======
+
+    public function id(): ?string
+    {
+        return $this->id;
+    }
+
+    public function contractPipelineId(): string
+    {
+        return $this->contractPipelineId;
+    }
+
+    public function exchangeOrderId(): ?string
+    {
+        return $this->exchangeOrderId;
+    }
+
+    public function clientOrderId(): string
+    {
+        return $this->clientOrderId;
+    }
+
+    public function symbol(): string
+    {
+        return $this->symbol;
+    }
+
+    public function side(): Side
+    {
+        return $this->side;
+    }
+
+    public function type(): OrderType
+    {
+        return $this->type;
+    }
+
+    public function price(): ?string
+    {
+        return $this->price;
+    }
+
+    public function size(): string
+    {
+        return $this->size;
+    }
+
+    public function leverage(): int
+    {
+        return $this->leverage;
+    }
+
+    public function openType(): OrderOpenType
+    {
+        return $this->openType;
+    }
+
+    public function status(): OrderStatus
+    {
+        return $this->status;
+    }
+
+    public function reason(): ?string
+    {
+        return $this->reason;
+    }
+
+    public function stateRaw(): ?int
+    {
+        return $this->stateRaw;
+    }
+
+    public function dealSize(): string
+    {
+        return $this->dealSize;
+    }
+
+    public function dealAvgPrice(): ?string
+    {
+        return $this->dealAvgPrice;
+    }
+
+    public function feesCum(): string
+    {
+        return $this->feesCum;
+    }
+
+    public function lastTradeId(): ?string
+    {
+        return $this->lastTradeId;
+    }
+
+    public function lastFillQty(): ?string
+    {
+        return $this->lastFillQty;
+    }
+
+    public function lastFillPrice(): ?string
+    {
+        return $this->lastFillPrice;
+    }
+
+    public function lastFee(): ?string
+    {
+        return $this->lastFee;
+    }
+
+    public function lastFeeCcy(): ?string
+    {
+        return $this->lastFeeCcy;
+    }
+
+    public function planOrderId(): ?string
+    {
+        return $this->planOrderId;
+    }
+
+    public function triggerPrice(): ?string
+    {
+        return $this->triggerPrice;
+    }
+
+    public function executionPrice(): ?string
+    {
+        return $this->executionPrice;
+    }
+
+    public function activationPrice(): ?string
+    {
+        return $this->activationPrice;
+    }
+
+    public function callbackRate(): ?string
+    {
+        return $this->callbackRate;
+    }
+
+    public function createdAt(): DateTimeImmutable
+    {
+        return $this->createdAt;
+    }
+
+    public function openedAt(): ?DateTimeImmutable
+    {
+        return $this->openedAt;
+    }
+
+    public function filledAt(): ?DateTimeImmutable
+    {
+        return $this->filledAt;
+    }
+
+    public function closedAt(): ?DateTimeImmutable
+    {
+        return $this->closedAt;
+    }
+
+    public function updatedAt(): DateTimeImmutable
+    {
+        return $this->updatedAt;
+    }
+
+    public function serverUpdateTimeMs(): ?string
+    {
+        return $this->serverUpdateTimeMs;
+    }
+
+    public function getStopLoss(): ?float
+    {
+        return $this->stopLoss;
+    }
+
+    public function setStopLoss(?float $stopLoss): static
+    {
+        $this->stopLoss = $stopLoss;
+
+        return $this;
+    }
+
+    public function getTakeProfit(): ?float
+    {
+        return $this->takeProfit;
+    }
+
+    public function setTakeProfit(?float $takeProfit): static
+    {
+        $this->takeProfit = $takeProfit;
+
+        return $this;
+    }
+}
